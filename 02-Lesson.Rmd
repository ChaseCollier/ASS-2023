# Tuesday, January 17, 2023 {-}

**"The trouble with programmers is that you can never tell what a programmer is doing until it's too late."** --- Seymour Cray

## An introduction to using R {-}

You save these ten values by assigning them to an object that you call `counts`. The assignment operator is a left-pointing arrow or equal sign (`<-` or `=`). The left-pointing arrow is the less than symbol followed by the hyphen.

```{r}
counts <- c(2, 3, 0, 3, 1, 0, 0, 1, 2, 1)
```

By clicking on the *Environment* tab in the upper-right panel you see that the object `counts` with numerical values (`num`) 2 3, etc below word *Values*. The elements of the vector object are indexed between 1 and 10 (`1:10`).

You print the values to the console by typing the name of the data object.

```{r}
counts
```

When printed the values are prefaced with a `[1]`. This indicates that the object is a vector and the first element in the vector has a value of 2 (The number immediately to the right of `[1]`).

Consider again the hurricane counts from the last ten years

You can assign and print by wrapping the entire line of code in parentheses

```{r}
( d1 <- c(2, 3, 0, 3, 1, 0, 0, 1, 2, 1) )
```

Suppose you are interested in the inter annual variability in the set of landfall counts. The variance is computed as

$$
\hbox{var}(x) = \frac{(x_1 - \bar x)^2 + (x_2 - \bar x)^2 + \cdots + (x_n - \bar x)^2}{n-1} = \frac{1}{n-1}\sum_{i=1}^n (x_i - \bar x)^2
$$

Note: the markdown file recognizes math written in LaTeX. The formula for the variance is written using LaTeX notation gets rendered as a math equation as in a textbook. See <https://www.overleaf.com/learn/latex/Mathematical_expressions>.

Although the `var()` function computes this, here you see how to do this using simple functions. The key is to find the squared differences and then sum.

```{r}
x <- d1
xbar <- mean(x)
x - xbar
(x - xbar)^2
sum((x - xbar)^2)
n <- length(x)
n
sum((x - xbar)^2)/(n - 1)
var(x)
```

Elements in a vector object must all have the same type. This type can be numeric, as in counts, character strings, as in

```{r}
simpsons <- c('Homer', 'Marge', 'Bart', 'Lisa', 'Maggie')
simpsons
```

Character strings are made with matching quotes, either double, `"`, or single, `'`. If you mix types the values will be coerced into a common type, which is usually a character string. Arithmetic operations do not work on character strings.

Returning to the land falling hurricane counts. Now suppose the National Hurricane Center (NHC) reanalyzes a storm, and that the 6th year of the decade is a 1 rather than a 0 for the number of landfalls. In this case you change the sixth element to have the value 1.

```{r}
d1[6] <- 1
```

You assign to the 6th year of the decade a value of one. The square brackets `[]` are used to reference elements of the data vector.

It is important to keep this straight: Parentheses `()` are used by functions and square brackets `[]` are used by data objects.

```{r}
d2
d2[2]
d2[-4]
d2[c(1, 3, 5, 7, 9)]
```

The first line prints all the elements of the vector `df2`. The second prints only the 2nd value of the vector. The third prints all but the 4th value. The fourth prints the values with odd element numbers.

To create structured data, for example the integers 1 through 99 you can use the `:` operator.

```{r, eval=FALSE}
1:99
rev(1:99)
99:1
```

The `seq()` function is more general. You specify the sequence interval with the `by =` or `length =` arguments.

```{r}
seq(from = 1, to = 9, by = 2)
seq(from = 1, to = 10, by = 2)
seq(from = 1, to = 9, length = 5)
```

The `rep()` function is used to create repetitive sequences. The first argument is a value or vector that you want repeated and the second argument is the number of times you want it repeated.

```{r}
rep(1, times = 10)
rep(simpsons, times = 2)
```

In the second example the vector `simpsons` containing the Simpson characters is repeated twice.

To repeat each element of the vector use the `each =` argument.

```{r}
rep(simpsons, each = 2)
```

More complicated patterns can be repeated by specifying pairs of equal length vectors. In this case, each element of the first vector is repeated the corresponding number of times given by the element in the second vector.

```{r}
rep(c("long", "short"),  times = c(2, 3))
```

To find the maximum number of landfalls during the first decade you type

```{r}
max(d1)
```

What years had the maximum?

```{r}
d1 == 3
```

Notice the double equals signs (`==`). This is a logical operator that tests each value in `d1` to see if it is equal to 3. The 2nd and 4th values are equal to 3 so `TRUE`s are returned.

Think of this as asking R a question. Is the value equal to 3? R answers all at once with a vector of `TRUE`'s and `FALSE`'s.

What years had more than 2 hurricanes?

```{r}
d1 > 2
```

Now the question is how do you get the vector element corresponding to the `TRUE` values? That is, which years have 3 landfalls?

```{r}
which(d1 == 3)
```

The function `which.max()` can be used to get the first maximum.

```{r}
which.max(d1)
```

You might also want to know the total number of landfalls in each decade and the number of years in a decade without a landfall. Or how about the ratio of the mean number of landfalls over the two decades.

```{r}
sum(d1)
sum(d2)
sum(d1 == 0)
sum(d2 == 0)
mean(d2)/mean(d1)
```

So there are 85% more landfalls during the second decade. Is this difference statistically significant?

To remove an object from your environment use the `rm()` function.

```{r}
rm(d1)
```

## Data frames {-}

Spatial data frames will be used throughout this course. A spatial data frame is a data frame plus information about the spatial geometry. Let's start with data frames.

A data frame stores data in a tabular format like a spreadsheet. It is a list of vectors each with the same length. It has column names (and sometimes row names).

For example, you create a data frame object `df` containing three vectors `n`, `s`, `b` each with three elements using the `data.frame()` function.

```{r}
n <- c(2, 3, 5) 
s <- c("aa", "bb", "cc") 
b <- c(TRUE, FALSE, TRUE) 

df <- data.frame(n, s, b)
```

To see that the object is indeed a data frame you use the `class()` function with the name of the object inside the parentheses.

```{r}
class(df)
```

The object `df` is of class `data.frame`. Note that the object name shows up in our *Environment* under *Data* and it includes a little blue arrow indicating that you can view it by clicking on the row.

The data frame shows up as a table (like a spreadsheet) in the `View()` mode (see the command in the console below). Caution: This is not advised for large data frames.

The top line of the table is called the header. Each line below the header contains a row of data, which begins with the name (or number) of the row followed by the data values.

Each data element is in a cell. To retrieve a data value from a cell, you enter its row and column coordinates in that order in the single square bracket `[]` operator and separated by a column.

df[row, column]

Here is the cell value from the first row, second column of `df`.

```{r}
df[1, 2]
```

You can print the column names (located in the top row in the `View()` mode) with the `names()` function.

```{r}
names(df)
```

The list of names is a vector of length three containing the elements "n", "s", and "b" in that order.

You access individual columns of a data frame as vectors by appending the dollar sign (`$`) to the object name. For example, to print the values of the column labeled `s` type

```{r}
df$s
```

Many of the packages you use this semester include example data frames. The data frame called `mtcars`, for instance, contains information extracted from the 1974 Motor Trend US magazine, and comprises fuel consumption and 10 aspects of automobile design and performance for 32 automobiles (1973--74 models).

```{r}
class(mtcars)

names(mtcars)
```

The number of data rows and data columns in the data frame are printed using the `nrow()` and `ncol()` functions.

```{r}
nrow(mtcars)
ncol(mtcars)
```

Further details of built-in data frames like `mtcars` is available in the documentation accessed with the `help()` (or `?`) function.

```{r, eval=FALSE}
help(mtcars)
```

If you type the name of the data frame in the console all the data are printed.

```{r}
mtcars
```

Instead, you can use the function `head()`, which prints the first six rows, or `str()`, which lists all the columns by data type.

```{r}
head(mtcars)

str(mtcars)
```

## Working with data frames using base R {.unnumbered}

Consider the data frame `studentdata` from the {LearnBayes} package. To access this data frame, first install the package with the `install.packages()` function.

You put the name of the package {LearnBayes} in quotes (single or double). Then to make the functions from the package available to your current session use the `library()` function with the name of the package (unquoted) inside the parentheses.

```{r}
if(!require(LearnBayes)) install.packages(pkgs = "LearnBayes", repos = "http://cran.us.r-project.org")

library(LearnBayes)
```

Note: The argument `repos =` in the `install.packages()` function directs where the package can be obtained on CRAN (comprehensive R archive network). The CRAN repository is set automatically when using RStudio and you can install packages by clicking on *Packages* \> *Install* in the lower-right panel.

For interactive use you need to specify the repository and when you use the `Knit` button you don't want to install packages that already exist on your computer so you add the conditional `if()` function that says "only install the package IF it is not (`!`) available".

Make a copy of the data frame by assigning it to an object with the name `df` and print the first six rows using the `head()` function.

```{r}
df <- studentdata
head(df)
```

Data frames are like spreadsheets with rows and columns. The rows are the observations (here each row is a student in an intro stats class at Bowling Green State University) and the columns are the variables. Here the variables are answers to questions like what is your height, choose a number between 1 and 10, what time did you go to bed last night, etc.

The names of the columns are printed using the `names()` function.

```{r}
names(df)
```

All columns are of the same length, but not all students answered all questions so some of the data frame cells contain the missing-value indicator `NA` (not available).

Data values in a data frame are stored in rows and columns and are accessed with bracket notation [row, column] where row is the row number and column is the column number like a matrix.

For example here you specify the data value in the 10th row and 2nd column (`Height` column) of the `df` data frame.

```{r}
df[10, 2]
```

By specifying only the row index and leaving the column index blank you get all values in that row, which corresponds to all the responses given by the 10th student.

```{r}
df[10, ]
```

Drink preference was one of the questions. Responses across all students are available in the column labeled `Drink` as a vector of character values. You list the various drink preferences by typing

```{r}
df$Drink
```

Some students left that response blank and therefore the response is coded with the missing-value indicator.

The variable type depends on the question asked. For example, answers given to the question of student height result in a numeric variable, answers given to the question about drink preference result in a character (or factor) variable.

For integer, character, and factor variables you summarize the set of responses with the `table()` function.

```{r}
table(df$Drink)
```

There are 113 students who prefer milk, 178 prefer soda, and 355 prefer water.

You can use the base R `plot()` method to make a draft plot of this table.

```{r}
plot(x = df$Drink)
```

Notice that the sum of the responses is `r sum(table(df$Drink))`, which is less than the total number of students (`r nrow(df)`).

Students who left that question blank are ignored in the `table()` function. To include the missing values you add the argument `useNA = "ifany"` to the `table()` function.

```{r}
table(df$Drink, 
      useNA = "ifany")
```

Note: When you want code executed directly within the text you separate the code using single back ticks. This is useful when you write reports that need periodic updates when new data becomes available. Instead if you hard code the values in the text then you need to search the document for these values during each update.

Suppose you are interested in examining how long students reported sleeping during the night. This was not asked directly. You compute it from the `ToSleep` and `WakeUp` times columns. You assign the result of the difference to a column we call `SleepHrs`.

```{r}
df$SleepHrs <- df$WakeUp - df$ToSleep
head(df)
```

Now you have a new numeric variable in the data frame called `SleepHrs`.

You can't table numeric variables, but the `summary()` method prints a set of summary statistics for the set of values.

```{r}
summary(df$SleepHrs)
```

The average number of hours slept is 7.4 with a maximum of 12.5 and a minimum of 2.5. There are four students that did not answer either when they went to sleep or when they woke up questions.

You use the `hist()` function to construct a histogram of sleep hours.

```{r}
hist(x = df$SleepHrs)
```

The histogram function divides the number of sleep hours into one-hour bins and counts the number of students whose reported sleep hours falls into each bin. For example based on when they said they went to sleep and when the said they woke up, about 100 students slept between five and six hours the night before the survey.

Since the gender of each student is reported, you can make comparisons between those who identify as male and those who identify as female. For instance, do men sleep more than women? You can answer this question graphically with box plots using the `plot()` method. You specify the character variable on the horizontal axis (x) to be gender with the `x =` argument and the numeric variable on the vertical axis (y) with the `y =` argument.

```{r}
plot(x = df$Gender, 
     y = df$SleepHrs)
```

The plot reveals little difference in the amount of sleep.

Repeat for hair cut prices.

```{r}
plot(x = df$Gender, 
     y = df$Haircut)
```

Big difference.

Finally, is the amount of sleep for a student related to when they go to bed? If you place numeric variables on the x and y axes then you get a scatter plot.

```{r}
plot(x = df$ToSleep,
     y = df$SleepHrs)
```

The `ToSleep` variable is centered on midnight so that -2 means a student went to sleep at 10p.

You describe the decreasing relationship with a line through the points. The least-squares line is fit using the `lm()` function and the line is drawn on the existing plot with the `abline()` function applied to the linear regression object `model`.

```{r}
model <- lm(SleepHrs ~ ToSleep, 
            data = df)

plot(x = df$ToSleep,
     y = df$SleepHrs)
abline(model)
```

## Getting data into R {-}

Most of the time you will start by getting your data stored in a file into R. Secondary source data should be imported directly from repositories on the Web. When there is no API (application programming interface) to the repository, you need to first download the data.

For example, consider the regularly updated reports of tornadoes in the United States. The data repository is the Storm Prediction Center (SPC) <https://www.spc.noaa.gov/wcm/index.html#data>.

Here you are interested in the file called `1950-2021_actual_tornadoes.csv`. First you download the file from the site with the `download.file()` function specifying the location (`url =`) and a name you want the file to be called on your computer (`destfile =`).

```{r}
download.file(url = "http://www.spc.noaa.gov/wcm/data/1950-2021_actual_tornadoes.csv",
              destfile = here::here("data", "Tornadoes.csv"))
```

A file called `Tornadoes.csv` should now be located in the directory `data`. Click on the *Files* tab in the lower-right panel, then select the `data` folder.

Next you read (import) the file as a data frame using the `readr::read_csv()` function from the {tidyverse} group of packages.

```{r}
Torn.df <- readr::read_csv(file = here::here("data", "Tornadoes.csv"))
```

You preview the data frame using the `head()` function.

```{r}
head(Torn.df)
```

Each row is a unique tornado report. Observations for each report include the day and time, the state (`st`), the maximum EF rating (`mag`), the number of injuries (`inj`), the number of fatalities (`fat`), estimated property losses (`loss`), estimated crop losses (`closs`), start and end locations in decimal degrees longitude and latitude, length of the damage path in miles (`len`), width of the damage in yards (`wid`).

The total number of tornado reports in the data set is returned using the `nrow()` function.

```{r}
nrow(Torn.df)
```

To create a subset of the data frame that contains only tornadoes in years (`yr`) since 2001, you include the logical operator `yr >= 2001` inside the subset operator. The logical operator is placed in front of the comma since you want all *rows* where the result of the operator returns a value `TRUE`.

```{r}
Torn2.df <- Torn.df[Torn.df$yr >= 2001, ]
```

You see that there are fewer rows (tornado reports) in this new data frame assigned the object name `Torn2.df`.

You subset again, keeping only tornadoes with EF ratings (`mag` variable) greater than zero. Here you *recycle* the name `Torn2.df`.

```{r}
Torn2.df <- Torn2.df[Torn2.df$mag > 0, ]
```

Now you compute the correlation between EF rating (`mag`) and path length (`len`) with the `cor()` function. The first argument is the vector of EF ratings and the second argument is the vector of path lengths.

```{r}
cor(Torn2.df$mag, Torn2.df$len)
```

Path length is recorded in miles and path width in yards and the EF damage rating variable `mag` is numeric. Here you convert path length to kilometers, path width to meters, and the EF rating to a factor and include these changes as new columns in the data frame.

```{r}
Torn2.df$Length <- Torn2.df$len * 1609.34
Torn2.df$Width <- Torn2.df$wid * .9144
Torn2.df$EF <- factor(Torn2.df$mag)
```

Create side-by-side box plots of path length (in kilometers) by EF rating.

```{r}
plot(x = Torn2.df$EF, 
     y = Torn2.df$Length/1000)
```

Example: Annual U.S. hurricane counts

Here you import the data directly from the Web by specifying the URL as a character string using the `file =` argument.

```{r}
loc <- "http://myweb.fsu.edu/jelsner/temp/data/US.txt"
USHur.df <- readr::read_table(file = loc)
```

The `dim()` function returns the size of the data frame defined as the number of rows and the number of columns.

```{r}
dim(USHur.df)
```

There are 166 rows and 6 columns in the data frame. Each row is a year and the columns include `Year`, number of hurricanes (`All`), number of major hurricanes (`MUS`), number of Gulf coast hurricanes (`G`), number of Florida hurricanes (`FL`), and number of East coast hurricanes (`E`) in that order.

To get a glimpse of the data values you list the first six lines of the data frame using the `head()` function.

```{r}
head(USHur.df)
```

The distribution of Florida hurricane counts by year is obtained using the `table()` function and specifying the `FL` column with `df$FL`.

```{r}
table(USHur.df$FL)
```

There are 93 years without a FL hurricane, 43 years with exactly one hurricane, 24 years with two hurricanes, and so on.

Example: Statewide average rainfall in Florida

The data are monthly statewide average rainfall (in inches) for Florida starting in 1895. The data were obtained from <http://www.esrl.noaa.gov/psd/data/timeseries/>. 

I put values into a text editor and then uploaded the file to the Web at location <http://myweb.fsu.edu/jelsner/temp/data/FLprecip.txt>.

You get the data into R with the `readr::read_table()` function. You assign the data object the name `FLp.df`. You type the name of the object to see that it is a tabled data frame (tibble) with 117 rows and 13 columns.

```{r}
loc <- "http://myweb.fsu.edu/jelsner/temp/data/FLprecip.txt"
FLp.df <- readr::read_table(file = loc)
FLp.df
```

The first column is the year and the next 12 columns are the months.

What was the statewide rainfall during June of 1900?

What happens when you check the column (vector) labeled `Year` to see what elements are equal to 1900?

```{r}
FLp.df$Year == 1900
```

Returns a vector with one element equal to `TRUE`.

What happens when we use this vector to select the vector of June rainfall values?

```{r}
FLp.df$Jun[FLp.df$Year == 1900]
```

What year had the wettest March?

```{r}
FLp.df$Mar

max(FLp.df$Mar)

which.max(FLp.df$Mar)

FLp.df$Year[which.max(FLp.df$Mar)]
```

What month during 1965 was the wettest? How wet was it?

```{r}
FLp.df$Year == 1965

FLp.df[FLp.df$Year == 1965, ]

which.max(FLp.df[FLp.df$Year == 1965, 2:12])

which.max(FLp.df[FLp.df$Year == 1965, 2:12])

max(FLp.df[FLp.df$Year == 1965, 2:12])
```
