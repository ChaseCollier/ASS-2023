# Thursday January 19, 2023 {.unnumbered}

**"When I'm explaining some of the tidy verse principles and philosophy in R statistics, I often break down a home baked chunk of code and illustrate that 'it says what it does and it does what it says.'** --- Diane Beldame

## Working with data frames using functions from {dplyr} {-}

The functions in the {dplyr} package (part of the tidyverse set of packages) simplify working with data frames. The functions work only on data frames.

Function names are English language *verbs* so they are easier to remember. The verbs help you translate thought into code.

Here we consider some of verbs using the `airquality` data frame. The data frame contains air quality measurements taken in New York City between May and September 1973 (`?airquality`) at time when pollution levels in the city were at an all time high.

```{r}
dim(airquality)
head(airquality)
```

The columns include `Ozone` (ozone concentration in ppb), `Solar.R` (solar radiation in langleys), `Wind` (wind speed in mph), `Temp` (air temperature in degrees F), `Month`, and `Day`.

You get summary statistics on the values in each column with the `summary()` method.

```{r}
summary(airquality)
```

Note that columns that have missing values are tabulated. For example, there are 37 missing ozone measurements and 7 missing radiation measurements.

Importantly for making your code more human readable you can apply the `summary()` function on the `airquality` data frame using the pipe operator (`|>`).

```{r}
airquality |> summary()
```

You read the pipe as THEN. "take the `airquality` data frame THEN summarize the columns".

The pipe operator allows you to string together functions that when read by a human makes it easy to understand what is being done.

Think of it this way: suppose the object of interest is called `me` and there is a function called `wake_up()`. I could apply this function called `wake_up()` in two ways.

```{r, eval=FALSE}
wake_up(me)  # way number one, classical way

me |> wake_up()  # way number two, tidyverse way
```

The second way involves more typing but it is easier to read (the subject comes before the predicate like simple English grammar) and thus easier to understand. This becomes clear when stringing together functions.

Continuing with the made-up example, what happens to the result of `me` after the function `wake_up()` has been applied? I `get_out_of_bed()` and then `get_dressed()`.

Again, you can apply these functions in two ways.

```{r, eval=FALSE}
get_dressed(get_out_of_bed(wake_up(me)))

me |>
  wake_up() |>
  get_out_of_bed() |>
  get_dressed()
```

The order of the functions usually matters to the outcome. I can't get dressed before I wake up but I could get dressed without getting out of bed.

Note how I format the code. Each line is gets only one verb and each line ends with the pipe (except the last one). This makes it easier to read.

Continuing...

```{r, eval=FALSE}
me |>
  wake_up() |>
  get_out_of_bed() |>
  get_dressed() |>
  make_coffee() |>
  drink_coffee() |>
  leave_house()
```

Which is much better in terms of 'readability' then `leave_house(drink_coffee(make_coffee(get_dressed(get_out_of_bed(wake_up(me))))))`.

Tibbles are data frames that make working with data frames a little easier. R is an old language, and some things that were useful 10 or 20 years ago now get in your way. To make a data frame a tibble (tabular data frame) use the `as_tibble()` function.

```{r}
class(airquality)
airquality <- dplyr::as_tibble(airquality)
class(airquality)
```

Click on `airquality` in the environment. It is a data frame. We will use the terms 'tibble' and 'data frame' interchangeably in this class.

Now you are ready to look at some of the commonly used verbs and to see how to apply them to a data frame.

The function `select()` chooses variables by name. For example, choose the month (`Month`), day (`Day`), and temperature (`Temp`) columns.

```{r}
airquality |>
  dplyr::select(Month, Day, Temp)
```

The result is a data frame containing only the three columns with column names listed in the `select()` function.

Suppose you want a new data frame with only the temperature and ozone concentrations. You include an assignment operator (`<-`) and an object name (here `df`).

```{r}
df <- airquality |>
        dplyr::select(Temp, Ozone)
df
```

The verbs take data frames as input and return data frames.

The function `filter()` chooses observations based on specific values. Suppose you want only the observations where the temperature is at or above 80 F.

```{r}
airquality |>
  dplyr::filter(Temp >= 80)
```

The result is a data frame with the same 6 columns but now only 73 observations. Each of the observations has a temperature of at least 80 F.

Suppose you want a new data frame keeping only observations when temperature is at least 80 F and when winds are less than 5 mph.

```{r}
df <- airquality |> 
  dplyr::filter(Temp >= 80 & Wind < 5)
df
```

The function `arrange()` orders the rows by values given in a particular column.

```{r}
airquality |>
  dplyr::arrange(Solar.R)
```

The ordering is done from the lowest value of radiation to highest value. Here you see the first 10 rows. Note `Month` and `Day` are no longer chronological.

Repeat, but order by the value of air temperature.

```{r}
airquality |>
  dplyr::arrange(Temp)
```

Importantly you can string the functions together. For example select the variables radiation, wind, and temperature then filter by temperatures above 90 F and arrange by temperature.

```{r}
airquality |>
  dplyr::select(Solar.R, Wind, Temp) |>
  dplyr::filter(Temp > 90) |>
  dplyr::arrange(Temp)
```

The result is a data frame with three columns and 14 rows arranged by increasing temperatures above 90 F.

The `mutate()` function adds new columns to the data frame. For example, create a new column called `TempC` as the temperature in degrees Celsius. Also create a column called `WindMS` as the wind speed in meters per second.

```{r}
airquality |>
  dplyr::mutate(TempC = (Temp - 32) * 5/9,
                WindMS = Wind * .44704) 
```

The resulting data frame has 8 columns (two new ones) labeled `TempC` and `WindMS`.

On days when the temperature is below 60 F add a column giving the apparent temperature based on the cooling effect of the wind (wind chill) and then arrange from coldest to warmest apparent temperature.

```{r}
airquality |>
  dplyr::filter(Temp < 60) |>
  dplyr::mutate(TempAp = 35.74 + .6215 * Temp - 35.75 * Wind^.16 + .4275 * Temp * Wind^.16) |>
  dplyr::arrange(TempAp)
```

The `summarize()` function reduces the data frame based on a function that computes a statistic. For example, to compute the average wind speed during July or the average temperature during June type

```{r}
airquality |>
  dplyr::filter(Month == 7) |>
  dplyr::summarize(Wavg = mean(Wind))

airquality |>
  dplyr::filter(Month == 6) |>
  dplyr::summarize(Tavg = mean(Temp))
```

You've seen functions that compute statistics including `sum()`, `sd()`, `min()`, `max()`, `var()`, `range()`, `median()`. Others include:

|      Summary function | Description               |
|----------------------:|:--------------------------|
|          `dplyr::n()` | Length of the column      |
|      `dplyr::first()` | First value of the column |
|       `dplyr::last()` | Last value of the column  |
| `dplyr::n_distinct()` | Number of distinct values |

Find the maximum and median wind speed and maximum ozone concentration values during the month of May. Also determine the number of observations during May.

```{r}
airquality |>
  dplyr::filter(Month == 5) |>
  dplyr::summarize(Wmax = max(Wind),
                   Wmed = median(Wind),
                   OzoneMax = max(Ozone),
                   NumDays = dplyr::n())
```

The result gives an `NA` for the maximum value of ozone (`OzoneMax`) because there is at least one missing value in the `Ozone` column. You fix this with the `na.rm = TRUE` argument in the function `max()`.

```{r}
airquality |>
  dplyr::filter(Month == 5) |>
  dplyr::summarize(Wmax = max(Wind),
                   Wmed = median(Wind),
                   OzoneMax = max(Ozone, na.rm = TRUE),
                   NumDays = dplyr::n())
```

If you want to summarize separately for each month you use the `group_by()` function. You split the data frame by some variable (e.g., `Month`), apply a function to the individual data frames, and then combine the output.

Find the highest ozone concentration by month. Include the number of observations (days) in the month.

```{r}
airquality |>
  dplyr::group_by(Month) |>
  dplyr::summarize(OzoneMax =  max(Ozone, na.rm = TRUE),
                   NumDays = dplyr::n())
```

Find the average ozone concentration when temperatures are above and below 70 F. Include the number of observations (days) in the two groups.

```{r}
airquality |>
  dplyr::group_by(Temp >= 70) |>
  dplyr::summarize(OzoneAvg =  mean(Ozone, na.rm = TRUE),
                   NumDays = dplyr::n())
```

On average ozone concentration is higher on warm days (Temp \>= 70 F) days. Said another way; mean ozone concentration statistically depends on temperature.

The mean is a model for the data. The statistical dependency of the mean implies that a model for ozone concentration will be improved by including temperature as an explanatory variable.

In summary, the important verbs are

|          Verb | Description                                                                    |
|--------------------------------------:|:--------------------------------|
|    `select()` | selects columns; pick variables by their names                                 |
|    `filter()` | filters rows; pick observations by their values                                |
|   `arrange()` | re-orders the rows                                                             |
|    `mutate()` | creates new columns; create new variables with functions of existing variables |
| `summarize()` | summarizes values; collapse many values down to a single summary               |
|  `group_by()` | allows operations to be grouped                                                |

The six functions form the basis of a grammar for data. You can only alter a data frame by reordering the rows (`arrange()`), picking observations and variables of interest (`filter()` and `select()`), adding new variables that are functions of existing variables (`mutate()`), collapsing many values to a summary (`summarise()`), and conditioning on variables (`group_by()`).

The syntax of the functions are all the same:

-   The first argument is a data frame. This argument is implicit when using the `|>` operator.
-   The subsequent arguments describe what to do with the data frame. You refer to columns in the data frame directly (without using `$`).
-   The result is a new data frame

These properties make it easy to chain together many simple lines of code to do complex data manipulations and summaries all while making it easy to read by humans.
