[["tuesday-january-24-2023.html", "Tuesday January 24, 2023 Making graphs Introduction to simple features Geo-computation on simple features", " Tuesday January 24, 2023 “Good coding style is like correct punctuation: you can manage without it, butitsuremakesthingseasiertoread.” — Hadley Wickham First lab on Thursday Making graphs The {ggplot2} package is a popular graphics tool among data scientists where the functions are built to facilitate principles of good data visualization Map data to aesthetics Add layers Build in steps Make the functions available to your current working directory library(ggplot2) Example: U.S. tornadoes: Consider the tornado records in the file Tornadoes.csv. Import the data using the readr::read_csv() function then create new columns called Year, Month and EF using the dplyr::mutate() function ( Torn.df &lt;- readr::read_csv(file = here::here(&quot;data&quot;, &quot;Tornadoes.csv&quot;)) |&gt; dplyr::mutate(Year = yr, Month = as.integer(mo), EF = mag) ) ## Rows: 67558 Columns: 29 ## ── Column specification ──────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (4): mo, dy, st, stf ## dbl (23): om, yr, tz, stn, mag, inj, fat, loss, closs, slat, slon, elat, el... ## date (1): date ## time (1): time ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. ## # A tibble: 67,558 × 32 ## om yr mo dy date time tz st stf stn mag inj ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;time&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 192 1950 10 01 1950-10-01 21:00 3 OK 40 23 1 0 ## 2 193 1950 10 09 1950-10-09 02:15 3 NC 37 9 3 3 ## 3 195 1950 11 20 1950-11-20 02:20 3 KY 21 1 2 0 ## 4 196 1950 11 20 1950-11-20 04:00 3 KY 21 2 1 0 ## 5 197 1950 11 20 1950-11-20 07:30 3 MS 28 14 1 3 ## 6 194 1950 11 04 1950-11-04 17:00 3 PA 42 5 3 1 ## 7 198 1950 12 02 1950-12-02 15:00 3 IL 17 7 2 3 ## 8 199 1950 12 02 1950-12-02 16:00 3 IL 17 8 3 25 ## 9 200 1950 12 02 1950-12-02 16:25 3 AR 5 12 3 0 ## 10 201 1950 12 02 1950-12-02 17:30 3 IL 17 9 1 0 ## # … with 67,548 more rows, and 20 more variables: fat &lt;dbl&gt;, loss &lt;dbl&gt;, ## # closs &lt;dbl&gt;, slat &lt;dbl&gt;, slon &lt;dbl&gt;, elat &lt;dbl&gt;, elon &lt;dbl&gt;, len &lt;dbl&gt;, ## # wid &lt;dbl&gt;, ns &lt;dbl&gt;, sn &lt;dbl&gt;, sg &lt;dbl&gt;, f1 &lt;dbl&gt;, f2 &lt;dbl&gt;, f3 &lt;dbl&gt;, ## # f4 &lt;dbl&gt;, fc &lt;dbl&gt;, Year &lt;dbl&gt;, Month &lt;int&gt;, EF &lt;dbl&gt; Next create a data frame (df) that contains the number of tornadoes by year for the state of Kansas ( df &lt;- Torn.df |&gt; dplyr::filter(st == &quot;KS&quot;) |&gt; dplyr::group_by(Year) |&gt; dplyr::summarize(nT = dplyr::n()) ) ## # A tibble: 72 × 2 ## Year nT ## &lt;dbl&gt; &lt;int&gt; ## 1 1950 30 ## 2 1951 77 ## 3 1952 19 ## 4 1953 29 ## 5 1954 68 ## 6 1955 96 ## 7 1956 57 ## 8 1957 63 ## 9 1958 49 ## 10 1959 65 ## # … with 62 more rows Then use the functions from {ggplot2} to graph the number of tornadoes by year using lines to connect the values neighboring values of the variable on the x-axis (Year) ggplot(data = df, mapping = aes(y = nT, x = Year)) + geom_line() + geom_point() Add another aesthetic by mapping the number of tornadoes to color Add color separately Early in the research, I like to break the code into steps as above: (1) Import the data, (2) manipulate the data, and (3) plot the data It is easier to document this way, but it introduces the potential for mistakes because of the intermediary objects in the environment (e.g., Torn.df, df) Below you bring together the above code chunks to create the time series of Kansas tornado frequency without creating objects readr::read_csv(file = here::here(&quot;data&quot;, &quot;Tornadoes.csv&quot;)) |&gt; dplyr::mutate(Year = yr, Month = as.integer(mo), EF = mag) |&gt; dplyr::filter(st == &quot;KS&quot;) |&gt; dplyr::group_by(Year) |&gt; dplyr::summarize(nT = dplyr::n()) |&gt; ggplot(mapping = aes(x = Year, y = nT)) + geom_line() + geom_point() The group_by() function conditions the output on the value of a variable For example to get a count of the number of tornadoes by EF damage rating since 2007 and ignoring tornadoes with missing ratings Torn.df |&gt; dplyr::filter(Year &gt;= 2007, EF != -9) |&gt; dplyr::group_by(EF) |&gt; dplyr::summarize(Count = dplyr::n()) ## # A tibble: 6 × 2 ## EF Count ## &lt;dbl&gt; &lt;int&gt; ## 1 0 9614 ## 2 1 6012 ## 3 2 1546 ## 4 3 393 ## 5 4 83 ## 6 5 9 The result is a table listing the number of tornadoes grouped by EF rating Instead of printing the table, you create a bar chart using the geom_col() function from {ggplot2} Torn.df |&gt; dplyr::filter(Year &gt;= 2007, EF != -9) |&gt; dplyr::group_by(EF) |&gt; dplyr::summarize(Count = dplyr::n()) |&gt; ggplot(mapping = aes(x = EF, y = Count)) + geom_col() Note that the grouping and summarizing can be done with the geom_bar() function, which counts the number of cases at each x position Torn.df |&gt; dplyr::filter(Year &gt;= 2007, EF != -9) |&gt; ggplot(mapping = aes(x = EF)) + geom_bar() Improve the bar chart and to make it ready for publication Torn.df |&gt; dplyr::filter(Year &gt;= 2007, EF != -9) |&gt; dplyr::group_by(EF) |&gt; dplyr::summarize(Count = dplyr::n()) |&gt; ggplot(mapping = aes(x = factor(EF), y = Count, fill = Count)) + # geom_bar(stat = &quot;identity&quot;) + geom_col() + xlab(&quot;EF Rating&quot;) + ylab(&quot;Number of Tornadoes&quot;) + scale_fill_continuous(low = &#39;green&#39;, high = &#39;orange&#39;) + geom_text(aes(label = Count), vjust = -.5, size = 3) + theme_minimal() + theme(legend.position = &#39;none&#39;) You create a set of plots with the facet_wrap() function. Here you create a set of bar charts showing the frequency of tornadoes by EF rating for each year in the data set since 2004 You add the function after the geom_bar() layer and use the formula syntax (~ Year) inside the parentheses. You interpret the syntax as “create bar charts conditioned on the variable year” Torn.df |&gt; dplyr::filter(Year &gt;= 2004, EF != -9) |&gt; ggplot(mapping = aes(x = factor(EF))) + geom_bar() + facet_wrap(~ Year) If you want more practice with using {ggplot2} go to the Data Visualization chapter of R for Data Science https://r4ds.had.co.nz/data-visualisation.html Introduction to simple features The vector model for data (vector data) represents things in the world using points, lines and polygons. These objects have discrete, well-defined borders and a high level of precision. Precision does not imply accuracy The raster model for data (raster data) represents continuous fields (like elevation and rainfall) using a grid of cells (raster). A raster aggregates fields to a given resolution, meaning that they are consistent over space and scale-able. The smallest features within the field are blurred or lost The choice data model depends on the application: Vector data dominates the social sciences because human settlements and boundaries have discrete borders. Raster data (e.g., remotely sensed imagery) dominates the environmental sciences because environmental conditions are typically continuous. Geographers, ecologists, demographers use vector and raster data Here we will use functions from the {sf} package to work with vector data and functions in the {terra} and {raster} packages to work with raster data sets. We will also look at functions from the new {stars} package that work with both vector and raster data models R’s spatial ecosystem continues to evolve. Most changes build on previous work. Occasionally there is a significant change that builds from scratch. The introduction of the {sf} package in 2018 is a significant change sf for simple features Simple features is a standard from the Open (‘open source’) Geospatial Consortium (OGC) to represent geographic information. It condenses geographic forms into a single geometry class The standard is used in spatial databases (e.g., PostGIS), commercial GIS (e.g., ESRI) and forms the vector data basis for libraries such as GDAL. A subset of simple features forms the GeoJSON standard. The {sf} package supports these classes and includes plotting and other methods Functions in the {sf} package work with all common vector geometry types: points, lines, polygons and their respective ‘multi’ versions (which group together features of the same type into a single feature). The functions also work with geometry collections, which contain multiple geometry types in a single object. The raster data classes are not supported The {sf} package incorporates the three main packages of the spatial R ecosystem: {sp} for the class system, {rgdal} for reading and writing data, and {rgeos} for spatial operations done with GEOS Simple features are data frames with a column for storing the spatial information. The spatial column is called geometry (or geom). The geometry column is referenced like a regular column but it has special features The geometry column is a ‘list column’ of class sfc (simple feature column). And the sfc is a set of objects of class sfg (simple feature geometries). Simple Feature Anatomy green box is a simple feature: a single record (observation), or data.frame row, consisting of attributes and geometry blue box is a single simple feature geometry (an object of class sfg) red box a simple feature column as a list (an object of class sfc, which is a column in the data.frame) the geometries are given in well-known text (WKT) format Geometries are the building blocks of simple features. Well-known text (WKT) is the way simple feature geometries are coded. Well-known binaries (WKB) are hexadecimal strings readable by computers. GIS and spatial databases use WKB to transfer and store geometry objects. WKT is a human-readable text description of simple features. The two formats are exchangeable See: https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry In WKT format a point is a coordinate in 2D, 3D or 4D space (see vignette(\"sf1\") for more information) such as POINT (5 2) The first number is the x coordinate and the second number is the y coordinate A line string is a sequence of points with a straight line connecting the points, for example LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2) Each pair of x and y coordinates is separated with a comma A polygon is a sequence of points that form a closed, non-intersecting ring. Closed means that the first and the last point of a polygon have the same coordinates. A polygon has one exterior boundary (outer ring) but it can have interior boundaries (inner rings). An inner ring is called a ‘hole’ Polygon without a hole - POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5)) Here there are two parentheses to start and two to end the string of coordinates Polygon with one hole - POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5), (2 4, 3 4, 3 3, 2 3, 2 4)) Here the first set of coordinates defines the outer edge of the polygon and the next set of coordinates defines the hole. The outer edge vertexes are connected in a counterclockwise direction. The inner edge vertexes (defining the hole in the polygon) are connected in a clockwise direction Simple features allow multiple geometries (‘geometry collection’) using ‘multi’ version of each geometry type Multi-point - MULTIPOINT (5 2, 1 3, 3 4, 3 2) Multi-string - MULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 2, 2 4)) Multi-polygon - MULTIPOLYGON (((1 5, 2 2, 4 1, 4 4, 1 5), (0 2, 1 2, 1 3, 0 3, 0 2))) The difference between a multi-point and multi-string is an extra set of parentheses. The difference between a polygon with a hole and a multi-polygon is that the vertexes of each polygon are connected in a counterclockwise direction A collection of these is made: Geometry collection - GEOMETRYCOLLECTION (MULTIPOINT (5 2, 1 3, 3 4, 3 2), LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2))) Simple feature geometry (sfg) The sfg class represents the simple feature geometry types: point, line string, polygon (and their ‘multi’ equivalents, such as multi points) or geometry collection Usually you don’t need to create geometries. Geometries are part of the spatial data you import. However, there are a set of functions to create simple feature geometry objects (sfg) from scratch, if needed. The names of these functions are simple and consistent, as they all start with the st_ prefix and end with the name of the geometry type in lowercase letters: A point - st_point() A linestring - st_linestring() A polygon - st_polygon() A multipoint - st_multipoint() A multilinestring - st_multilinestring() A multipolygon - st_multipolygon() A geometry collection - st_geometrycollection() An sfg object can be created from three data types: A numeric vector - a single point A matrix - a set of points, where each row contains a point - a multi-point or line string A list - any other set, e.g. a multi-line string or geometry collection To create point objects, you use the st_point() function from the {sf} package applied to a numeric vector sf::st_point(c(5, 2)) # XY point ## POINT (5 2) sf::st_point(c(5, 2, 3)) # XYZ point ## POINT Z (5 2 3) To create multi-point objects, you use matrices here constructed from the rbind() function mp.matrix &lt;- rbind(c(5, 2), c(1, 3), c(3, 4), c(3, 2)) mp.matrix ## [,1] [,2] ## [1,] 5 2 ## [2,] 1 3 ## [3,] 3 4 ## [4,] 3 2 sf::st_multipoint(mp.matrix) ## MULTIPOINT ((5 2), (1 3), (3 4), (3 2)) ls.matrix &lt;- rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2)) sf::st_linestring(ls.matrix) ## LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2) sf::st_linestring(ls.matrix) ## LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2) plot(sf::st_multipoint(mp.matrix)) plot(sf::st_linestring(ls.matrix)) To create a polygon, you use lists poly.list &lt;- list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5))) sf::st_polygon(poly.list) ## POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5)) poly.border &lt;- rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5)) poly.hole &lt;- rbind(c(2, 4), c(3, 4), c(3, 3), c(2, 3), c(2, 4)) poly.with.hole.list &lt;- list(poly.border, poly.hole) sf::st_polygon(poly.with.hole.list) ## POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5), (2 4, 3 4, 3 3, 2 3, 2 4)) plot(sf::st_polygon(poly.list)) plot(sf::st_polygon(poly.with.hole.list)) Simple feature geometry column One sfg object contains a single simple feature geometry. A simple feature geometry column (sfc) is a list of sfg objects together with information about the coordinate reference system For example, to combine two simple features into one object with two features, you use the st_sfc() function. This is important since sfg represents the geometry column in sf data frames point1 &lt;- sf::st_point(c(5, 2)) point2 &lt;- sf::st_point(c(1, 3)) sf::st_sfc(point1, point2) ## Geometry set for 2 features ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: 1 ymin: 2 xmax: 5 ymax: 3 ## CRS: NA ## POINT (5 2) ## POINT (1 3) In most cases, a sfc object contains objects of the same geometry type. Thus, when you convert sfg objects of type polygon into a simple feature geometry column, you end up with an sfc object of type polygon. A geometry column of multiple line strings would result in an sfc object of type multilinestring An example with polygons poly.list1 &lt;- list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5))) polygon1 &lt;- sf::st_polygon(poly.list1) poly.list2 &lt;- list(rbind(c(0, 2), c(1, 2), c(1, 3), c(0, 3), c(0, 2))) polygon2 &lt;- sf::st_polygon(poly.list2) sf::st_sfc(polygon1, polygon2) ## Geometry set for 2 features ## Geometry type: POLYGON ## Dimension: XY ## Bounding box: xmin: 0 ymin: 1 xmax: 4 ymax: 5 ## CRS: NA ## POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5)) ## POLYGON ((0 2, 1 2, 1 3, 0 3, 0 2)) plot(sf::st_sfc(polygon1, polygon2)) An example with line strings mls.list1 &lt;- list(rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2)), rbind(c(1, 2), c(2, 4))) mls1 &lt;- sf::st_multilinestring((mls.list1)) mls.list2 &lt;- list(rbind(c(2, 9), c(7, 9), c(5, 6), c(4, 7), c(2, 7)), rbind(c(1, 7), c(3, 8))) mls2 &lt;- sf::st_multilinestring((mls.list2)) sf::st_sfc(mls1, mls2) ## Geometry set for 2 features ## Geometry type: MULTILINESTRING ## Dimension: XY ## Bounding box: xmin: 1 ymin: 1 xmax: 7 ymax: 9 ## CRS: NA ## MULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 ... ## MULTILINESTRING ((2 9, 7 9, 5 6, 4 7, 2 7), (1 ... plot(sf::st_sfc(mls1, mls2)) An example with a geometry collection sf::st_sfc(point1, mls1) ## Geometry set for 2 features ## Geometry type: GEOMETRY ## Dimension: XY ## Bounding box: xmin: 1 ymin: 1 xmax: 5 ymax: 5 ## CRS: NA ## POINT (5 2) ## MULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 ... The first simple feature is a point the next is a multilinestring A sfc object also stores information on the coordinate reference system (CRS). To specify a CRS, you use the epsg or proj4string attributes. The default value of epsg and proj4string is NA (Not Available) sf::st_sfc(point1, point2) ## Geometry set for 2 features ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: 1 ymin: 2 xmax: 5 ymax: 3 ## CRS: NA ## POINT (5 2) ## POINT (1 3) All geometries in an sfc object must have the same CRS. You add coordinate reference system as a crs = argument in st_sfc(). The argument accepts an integer with the epsg (European Petroleum Survey Group) code (for example, 4326) ( sfc1 &lt;- sf::st_sfc(point1, point2, crs = 4326) ) ## Geometry set for 2 features ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: 1 ymin: 2 xmax: 5 ymax: 3 ## Geodetic CRS: WGS 84 ## POINT (5 2) ## POINT (1 3) The epsg code is translated to a well-known text (WKT) representation of the CRS sf::st_crs(sfc1) ## Coordinate Reference System: ## User input: EPSG:4326 ## wkt: ## GEOGCRS[&quot;WGS 84&quot;, ## ENSEMBLE[&quot;World Geodetic System 1984 ensemble&quot;, ## MEMBER[&quot;World Geodetic System 1984 (Transit)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G730)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G873)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G1150)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G1674)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G1762)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G2139)&quot;], ## ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, ## LENGTHUNIT[&quot;metre&quot;,1]], ## ENSEMBLEACCURACY[2.0]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## CS[ellipsoidal,2], ## AXIS[&quot;geodetic latitude (Lat)&quot;,north, ## ORDER[1], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## AXIS[&quot;geodetic longitude (Lon)&quot;,east, ## ORDER[2], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## USAGE[ ## SCOPE[&quot;Horizontal component of 3D system.&quot;], ## AREA[&quot;World.&quot;], ## BBOX[-90,-180,90,180]], ## ID[&quot;EPSG&quot;,4326]] Here the WKT describes a two-dimensional geographic coordinate reference system (GEOCRS) with a latitude axis first, then a longitude axis. The coordinate system is related to Earth by the WGS84 geodetic datum. See: https://en.wikipedia.org/wiki/Well-known_text_representation_of_coordinate_reference_systems Simple feature data frames Simple features typically come with attributes. The attributes might represent the name of the geometry, measured values, groups to which the geometry belongs, etc The simple feature class, sf, is a combination of an attribute table (data.frame) and a simple feature geometry column (sfc). Simple feature objects are created using the st_sf() function Objects of class sf behave like regular data frames. methods(class = &quot;sf&quot;) ## [1] [ [[&lt;- $&lt;- aggregate as.data.frame ## [6] cbind coerce filter identify initialize ## [11] merge plot print rbind show ## [16] slotsFromS3 transform ## see &#39;?methods&#39; for accessing help and source code Simple features have two classes, sf and data.frame. This is central to the concept of simple features: most of the time a sf can be treated as, and behaves like, a data.frame. Simple features are data frames but with a column containing the geometric information (sfc) I refer to simple feature objects as ‘simple feature data frames’ to distinguish them from S4 class spatial data frames Many of these functions were developed for data frames including rbind() (for binding rows of data together) and $ (for creating new columns). The key feature of sf objects is that they store spatial and non-spatial data in the same way (columns in a data.frame) The geometry column of {sf} objects is typically labeled geometry but any name can be used Thus sf objects take advantage of R’s data analysis capabilities to be used on geographic data. It’s worth reviewing how to discover basic properties of vector data objects For example, you get information about the size and breadth of the world simple feature data frame from the {spData} package using dim(), nrow(), etc library(spData) dim(world) ## [1] 177 11 nrow(world) ## [1] 177 ncol(world) ## [1] 11 The data contains ten non-geographic columns (and one geometry column) with 177 rows each one representing a country Extracting the attribute data from an sf object is the same as dropping its geometry world.df &lt;- world |&gt; sf::st_drop_geometry() class(world.df) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; Example: Temperatures at FSU and at the airport Suppose you measure a temperature of 5C at FSU and 0C at the airport at 7a on January 24, 2023. Thus, you have specific points in space (the coordinates), the name of the locations (FSU, Airport), temperature values and the date of the measurement. Other attributes might include a urbanity category (campus or city), or a remark if the measurement was made with an automatic station Start by creating to sfg (simple feature geometry) point objects FSU.point &lt;- sf::st_point(c(-84.29849, 30.44188)) TLH.point &lt;- sf::st_point(c(-84.34505, 30.39541)) Then combine the point objects into a sfc (simple feature column) object locations &lt;- sf::st_sfc(FSU.point, TLH.point, crs = 4326) Then create a data frame of attributes attributes &lt;- data.frame(name = c(&quot;FSU&quot;, &quot;Airport&quot;), temperature = c(5, 0), date = rep(as.Date(&quot;2023-01-24&quot;), times = 2), category = c(&quot;campus&quot;, &quot;airport&quot;), automatic = c(TRUE, FALSE)) Finally create a simple feature data frame ( sfdf &lt;- sf::st_sf(attributes, geometry = locations) ) ## Simple feature collection with 2 features and 5 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: -84.34505 ymin: 30.39541 xmax: -84.29849 ymax: 30.44188 ## Geodetic CRS: WGS 84 ## name temperature date category automatic geometry ## 1 FSU 5 2023-01-24 campus TRUE POINT (-84.29849 30.44188) ## 2 Airport 0 2023-01-24 airport FALSE POINT (-84.34505 30.39541) The example illustrates the components of sf objects. First, you use coordinates to define the geometry of the simple feature geometry (sfg). Second, you can combine the geometries into a simple feature geometry column (sfc) which also stores the CRS. Third, you store the attribute information on the geometries in a data.frame. Fourth, you use the st_sf() function to combine the attribute table and the sfc object into a sf object sfdf ## Simple feature collection with 2 features and 5 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: -84.34505 ymin: 30.39541 xmax: -84.29849 ymax: 30.44188 ## Geodetic CRS: WGS 84 ## name temperature date category automatic geometry ## 1 FSU 5 2023-01-24 campus TRUE POINT (-84.29849 30.44188) ## 2 Airport 0 2023-01-24 airport FALSE POINT (-84.34505 30.39541) class(sfdf) ## [1] &quot;sf&quot; &quot;data.frame&quot; Given a simple feature data frame you create a non-spatial data frame with a geometry list-column but that is not of class sf using the as.data.frame() function df &lt;- sfdf |&gt; as.data.frame() class(df) ## [1] &quot;data.frame&quot; In this case the geometry column is no longer a sfc. no longer has a plot method, and lacks all dedicated methods listed above for class sf In order to avoid confusion it might be better to use the st_drop_geometry() column instead df &lt;- sfdf |&gt; sf::st_drop_geometry() Example: US states The object us_states from the {spData} package is a simple feature data frame from the U.S. Census Bureau. The variables include the name, region, area, and population Simple feature data frames can be treated as regular data frames. But the geometry is “sticky”. For example when we create a new data frame containing only the population information the geometry column is included in the new data frame df1 &lt;- us_states |&gt; dplyr::select(starts_with(&quot;total&quot;)) head(df1) ## Simple feature collection with 6 features and 2 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: -114.8136 ymin: 24.55868 xmax: -71.78699 ymax: 42.04964 ## Geodetic CRS: NAD83 ## total_pop_10 total_pop_15 geometry ## 1 4712651 4830620 MULTIPOLYGON (((-88.20006 3... ## 2 6246816 6641928 MULTIPOLYGON (((-114.7196 3... ## 3 4887061 5278906 MULTIPOLYGON (((-109.0501 4... ## 4 3545837 3593222 MULTIPOLYGON (((-73.48731 4... ## 5 18511620 19645772 MULTIPOLYGON (((-81.81169 2... ## 6 9468815 10006693 MULTIPOLYGON (((-85.60516 3... The resulting data frame has the two population columns but also a column labeled geometry When you use the summarize() function, a union of the geometries across rows is made df2 &lt;- us_states |&gt; dplyr::filter(REGION == &quot;Midwest&quot;) |&gt; dplyr::summarize(TotalPop2010 = sum(total_pop_10), TotalPop2015 = sum(total_pop_15)) head(df2) ## Simple feature collection with 1 feature and 2 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: -104.0577 ymin: 35.99568 xmax: -80.51869 ymax: 49.38436 ## Geodetic CRS: NAD83 ## TotalPop2010 TotalPop2015 geometry ## 1 66514091 67546398 MULTIPOLYGON (((-85.48703 4... Why use the {sf} package when {sp} is already tried and tested? Fast reading and writing of data Enhanced plotting performance {sf} objects are treated as data frames in most operations {sf} functions are combined using |&gt; operator and they work well with the {tidyverse} packages {sf} function names are consistent and intuitive (all begin with st_) {sp} will be deprecated in the near future This has led to the development of spatial packages (including {tmap}, {mapview} and {tidycensus}) that support simple feature objects It is easy to convert between the two classes. Consider the world S3 spatial data frame from the {spData} package. You convert it to a S4 spatial data frame with the as() method world.sp &lt;- world |&gt; as(Class = &quot;Spatial&quot;) The method changes the simple features to Spatial* and Spatial*DataFrame objects of S4 data class You convert a S4 spatial data frame into a simple feature data frame with the st_as_sf() function world.sf &lt;- world.sp |&gt; sf::st_as_sf() You create maps from simple feature data frames with the base plot() method (plot.sf()). The function creates a multi-panel one sub-plot for each variable Geo-computation on simple features Geo-computation on simple features is done with routines in the geometry engine-open source (GEOS) library that the functions in the {sf} package make use of As an example, consider the file police.zip on my website that contains shapefiles in a folder called police. The variables include police expenditures (POLICE), crime (CRIME), income (INC), unemployment (UNEMP) and other socio-economic variables for counties in Mississippi Input the data using the st_read() function from the {sf} package and then assign a geographic coordinate reference system (CRS) to it using the EPSG number 4326. download.file(url = &quot;http://myweb.fsu.edu/jelsner/temp/data/police.zip&quot;, destfile = here::here(&quot;data&quot;, &quot;police.zip&quot;)) unzip(here::here(&quot;data&quot;, &quot;police.zip&quot;), exdir = here::here(&quot;data&quot;)) sfdf &lt;- sf::st_read(dsn = here::here(&quot;data&quot;, &quot;police&quot;), layer = &quot;police&quot;) ## Reading layer `police&#39; from data source ## `/Users/jameselsner/Desktop/ClassNotes/ASS-2023/data/police&#39; ## using driver `ESRI Shapefile&#39; ## Simple feature collection with 82 features and 21 fields ## Geometry type: POLYGON ## Dimension: XY ## Bounding box: xmin: -91.64356 ymin: 30.19474 xmax: -88.09043 ymax: 35.00496 ## CRS: NA sf::st_crs(sfdf) &lt;- 4326 The geometries are polygons and there are 82 of them, one for each county You transform the geographic coordinate system of the polygons to a specific projected CRS as suggested by the function suggest_crs() from the {crsuggest} package crsuggest::suggest_crs(sfdf) ## # A tibble: 10 × 6 ## crs_code crs_name crs_t…¹ crs_gcs crs_u…² crs_p…³ ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 6508 NAD83(2011) / Mississippi TM projec… 6318 m +proj=… ## 2 3816 NAD83(NSRS2007) / Mississippi TM projec… 4759 m +proj=… ## 3 3815 NAD83(HARN) / Mississippi TM projec… 4152 m +proj=… ## 4 3814 NAD83 / Mississippi TM projec… 4269 m +proj=… ## 5 6510 NAD83(2011) / Mississippi West (ftU… projec… 6318 us-ft +proj=… ## 6 6509 NAD83(2011) / Mississippi West projec… 6318 m +proj=… ## 7 3600 NAD83(NSRS2007) / Mississippi West … projec… 4759 us-ft +proj=… ## 8 3599 NAD83(NSRS2007) / Mississippi West projec… 4759 m +proj=… ## 9 2900 NAD83(HARN) / Mississippi West (ftU… projec… 4152 us-ft +proj=… ## 10 2814 NAD83(HARN) / Mississippi West projec… 4152 m +proj=… ## # … with abbreviated variable names ¹​crs_type, ²​crs_units, ³​crs_proj4 The function for transforming the CRS is st_transform() from the {sf} package sfdf &lt;- sfdf |&gt; sf::st_transform(crs = 6508) The st_centroid() function computes the geographic center of each polygon in the spatial data frame countyCenters.sf &lt;- sfdf |&gt; sf::st_centroid() ## Warning in st_centroid.sf(sfdf): st_centroid assumes attributes are constant ## over geometries of x The warning lets you know that the attributes attached to each polygon might result in misleading information when attached to the new geometry (points). Different geometries can mean different interpretations of the attribute sf::st_geometry(countyCenters.sf) ## Geometry set for 82 features ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: 347970.3 ymin: 1069814 xmax: 639099.2 ymax: 1565402 ## Projected CRS: NAD83(2011) / Mississippi TM ## First 5 geometries: ## POINT (607909.2 1565402) ## POINT (639099.2 1550199) ## POINT (577860 1552732) ## POINT (552191 1557790) ## POINT (478087.6 1564075) To get a geographic center location for the state, you first join all the counties using the st_union() function, then use the st_centroid() function stateCenter.sfc &lt;- sfdf |&gt; sf::st_union() |&gt; sf::st_centroid() The result is a simple feature geometry column (sfc) with a single row where the geometry contains the center location Which county contains the geographic center of the state? Here you use the geometric binary predicate st_contains() ( Contains &lt;- sfdf |&gt; sf::st_contains(stateCenter.sfc, sparse = FALSE) ) ## [,1] ## [1,] FALSE ## [2,] FALSE ## [3,] FALSE ## [4,] FALSE ## [5,] FALSE ## [6,] FALSE ## [7,] FALSE ## [8,] FALSE ## [9,] FALSE ## [10,] FALSE ## [11,] FALSE ## [12,] FALSE ## [13,] FALSE ## [14,] FALSE ## [15,] FALSE ## [16,] FALSE ## [17,] FALSE ## [18,] FALSE ## [19,] FALSE ## [20,] FALSE ## [21,] FALSE ## [22,] FALSE ## [23,] FALSE ## [24,] FALSE ## [25,] FALSE ## [26,] FALSE ## [27,] FALSE ## [28,] FALSE ## [29,] FALSE ## [30,] FALSE ## [31,] FALSE ## [32,] FALSE ## [33,] FALSE ## [34,] FALSE ## [35,] FALSE ## [36,] FALSE ## [37,] FALSE ## [38,] FALSE ## [39,] FALSE ## [40,] FALSE ## [41,] FALSE ## [42,] FALSE ## [43,] FALSE ## [44,] TRUE ## [45,] FALSE ## [46,] FALSE ## [47,] FALSE ## [48,] FALSE ## [49,] FALSE ## [50,] FALSE ## [51,] FALSE ## [52,] FALSE ## [53,] FALSE ## [54,] FALSE ## [55,] FALSE ## [56,] FALSE ## [57,] FALSE ## [58,] FALSE ## [59,] FALSE ## [60,] FALSE ## [61,] FALSE ## [62,] FALSE ## [63,] FALSE ## [64,] FALSE ## [65,] FALSE ## [66,] FALSE ## [67,] FALSE ## [68,] FALSE ## [69,] FALSE ## [70,] FALSE ## [71,] FALSE ## [72,] FALSE ## [73,] FALSE ## [74,] FALSE ## [75,] FALSE ## [76,] FALSE ## [77,] FALSE ## [78,] FALSE ## [79,] FALSE ## [80,] FALSE ## [81,] FALSE ## [82,] FALSE You include the sparse = FALSE argument so the result is a matrix containing TRUEs and FALSEs. Since there are 82 counties and one centroid the matrix has 82 rows and 1 column. All matrix entries are FALSE except the one containing the center To map the result you first plot the county polygons with the geom_sf() function (layer), then add the county geometry for the center county and fill it red. You use the matrix that you called Contains to subset this county. Finally you add the location of the state centroid to the plot ggplot(data = sfdf) + geom_sf() + geom_sf(data = sfdf[Contains, ], col = &quot;red&quot;) + geom_sf(data = stateCenter.sfc) + theme_void() The function st_area() returns a vector of the geographical area (in sq. units) of each of the spatial objects. Here county boundaries as polygons sfdf |&gt; sf::st_area() ## Units: [m^2] ## [1] 1059845789 1129805491 1177795196 1063555913 1292308911 1837313947 ## [7] 1209563206 1050434214 1081610367 1111684631 1789727469 1873807962 ## [13] 1537935343 1182321227 1047492468 1387412534 1298534836 1305083703 ## [19] 1689710519 1539012925 2325208833 2002801262 1320449739 1821075582 ## [25] 1165056081 1566560661 1062455271 1313215090 1103428267 1584296774 ## [31] 1053624790 1195801329 1966286085 1077116415 2004569381 1127253959 ## [37] 1933657382 1811075898 1604263674 1162255863 2412017942 1136584592 ## [43] 1491632367 1497746748 1952707326 1894657055 1566911457 1653697972 ## [49] 2045637420 1824649519 1481229225 2294433604 1797593028 1798362792 ## [55] 1625787733 1254286842 1564126825 2051293154 2027900509 1366995434 ## [61] 1858641378 1066358984 1072169833 1117271183 1208280395 1493574538 ## [67] 1450255735 1398323080 1284051541 1225628132 1695604706 1798766462 ## [73] 1811701938 1955125869 1067233035 1063132758 2151445783 1205245026 ## [79] 1177906764 1834858322 1533395797 1238226953 The vector values have units of square meters (m^2), which are derived from the CRS There is an attribute called AREA in the data frame but it is better to calculate it from the spatial polygons because then you are sure of the units What happens when you apply the area function on the centroid object? countyCenters.sf |&gt; sf::st_area() ## Units: [m^2] ## [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [39] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [77] 0 0 0 0 0 0 Compute a 10 km buffer around the state and show the result with a plot. First use st_union(), then st_buffer(), then pipe the output (a simple feature data frame to ggplot()) sfdf |&gt; sf::st_union() |&gt; sf::st_buffer(dist = 10000) |&gt; ggplot() + geom_sf() + geom_sf(data = sfdf) + theme_void() Length of boundary lines for U.S. states. Transform the CRS to 2163 (US National Atlas Equal Area). Note that the geometry is multi-polygons. Convert the polygons to multi-linestrings, then use st_length() to get the total length of the lines states &lt;- spData::us_states |&gt; sf::st_transform(crs = 2163) sf::st_length(states) # returns zeroes because geometry is polygon ## Units: [m] ## [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [39] 0 0 0 0 0 0 0 0 0 0 0 states |&gt; sf::st_cast(to = &quot;MULTILINESTRING&quot;) |&gt; sf::st_length() ## Units: [m] ## [1] 1710433.26 2298001.84 2102155.22 514571.45 2949041.87 1746686.74 ## [7] 2570625.84 1436260.52 1957704.71 2216035.60 1018647.33 2567370.61 ## [13] 2112070.19 2826608.77 2338551.23 747093.89 2296339.40 1771057.91 ## [19] 2334844.08 1497781.59 1275536.83 1998187.83 4959188.68 778627.31 ## [25] 1592462.66 1680675.61 3810365.04 407944.22 60329.77 1859164.04 ## [31] 1656525.21 1835778.08 1572793.19 1638356.40 3579150.33 1711366.62 ## [37] 2051115.13 782857.63 2378176.63 2221531.40 1467821.30 2198130.04 ## [43] 304698.28 1855108.54 1972765.77 2407304.31 2344371.69 1900586.84 ## [49] 2029017.32 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
