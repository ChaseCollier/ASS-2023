[["tuesday-april-25-2023.html", "Tuesday April 25, 2023 Assessing how well a point pattern model fits the data An example of a point process model in the wild Spatial logistic regression", " Tuesday April 25, 2023 “Sometimes it pays to stay in bed on Monday, rather than spending the rest of the week debugging Monday’s code.” - Christopher Thompson Assessing how well a point pattern model fits the data A good (useful) model should be capable of generating fake data that are statistically indistinguishable from the real data. With a point pattern model you produce samples of event locations with the simulate() function Let’s return to the Swedish pine sapling data and the inhibition model that you fit last time You assume a (stationary) Strauss process with interaction radius r. The parameters \\(\\beta\\) and \\(\\gamma\\) define the pairwise interaction in which each event contributes a factor \\(\\beta\\) to the intensity of the point pattern, and each pair of events closer than r units apart contributes a factor \\(\\gamma\\) to the intensity where \\(\\gamma\\) is less than one You use the ppm() function and include the point pattern data as the first argument. You set the trend term to a constant (implying a stationary process) with the argument trend = ~ 1 and the interaction radius to 10 units with the argument interaction = Strauss(r = 10) and a border correction out to a distance of 10 units from the window with the rbord = argument library(spatstat) ## Loading required package: spatstat.data ## Loading required package: spatstat.geom ## spatstat.geom 3.0-6 ## Loading required package: spatstat.random ## spatstat.random 3.1-3 ## Loading required package: spatstat.explore ## Loading required package: nlme ## spatstat.explore 3.0-6 ## Loading required package: spatstat.model ## Loading required package: rpart ## spatstat.model 3.1-2 ## Loading required package: spatstat.linnet ## spatstat.linnet 3.0-4 ## ## spatstat 3.0-3 ## For an introduction to spatstat, type &#39;beginner&#39; SP &lt;- swedishpines model.in &lt;- SP |&gt; ppm(trend = ~ 1, interaction = Strauss(r = 10), rbord = 10) Here you generate three samples of the Swedish pine sapling data and for comparison plot them alongside the actual data X &lt;- model.in |&gt; simulate(nsim = 3) ## Generating 3 simulated patterns ...1, 2, 3. plot(SP) plot(X[[1]]) plot(X[[2]]) plot(X[[3]]) The three samples of point pattern data all look similar to the actual data providing evidence that the inhibition model is adequate To quantitatively assess the similarity you can use the envelope() function to compute the \\(K\\) function on 99 samples from the model and on the actual data The \\(K\\) function values are averaged over all samples and a mean line represents the mean model curve. Uncertainty is assessed with a band that ranges from the minimum to the maximum K at each distance Do this with the inhibition model for the pine saplings. This takes a few seconds to complete model.in |&gt; envelope(fun = Kest, nsim = 99, correction = &#39;border&#39;) |&gt; plot(legend = FALSE) ## Generating 99 simulated realisations of fitted Gibbs model ... ## 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, ## 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, ## 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99. ## ## Done. The black line is the empirical (data) curve and the red line is the average over the 99 samples. The two lines are close and the black line falls nearly completely within the gray uncertainty band indicating the model fits the data well. The kink in the red curve is the result of specifying 10 units for the interaction distance From this plot you confidently conclude that a homogeneous inhibition model is adequate for describing the pine sapling data What about the cluster model for the maple trees? You used a Thomas cluster process which means that centered on each event the chance of a nearby event decays as a two-dimensional Gaussian distribution. The latent rate of a nearby event is a two-dimensional kernel This differs from a Matérn cluster process which means that centered on each event there is an equal chance of a nearby event out to some distance r Use use the kppm() function and include the point pattern data as the first argument. You assume stationarity so trend = ~ 1 and the argument clusters = is set to \"Thomas\" MT &lt;- lansing |&gt; subset(marks == &quot;maple&quot;) |&gt; unmark() ( model.cl &lt;- MT |&gt; kppm(trend = ~ 1, clusters = &quot;Thomas&quot;) ) ## Stationary cluster point process model ## Fitted to point pattern dataset &#39;MT&#39; ## Fitted by minimum contrast ## Summary statistic: K-function ## ## Uniform intensity: 514 ## ## Cluster model: Thomas process ## Fitted cluster parameters: ## kappa scale ## 21.74344366 0.06752959 ## Mean cluster size: 23.63931 points ## ## Cluster strength: phi = 0.8026 ## Sibling probability: psib = 0.4452 Now plot the \\(K\\) function on the data and on 99 model simulations. model.cl |&gt; envelope(fun = Kest, nsim = 99, correction = &#39;border&#39;) |&gt; plot(legend = FALSE) ## Generating 99 simulated realisations of fitted cluster model ... ## 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, ## 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, ## 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99. ## ## Done. In the case of the maple trees, a cluster model is adequate. However, it might not be satisfying since you know about the potential for inhibition caused by the presence of hickory trees Also there were more trees in the south than in the north so the stationary assumption is suspect You fit a second cluster model where the intensity is a linear function of distance in the north-south direction model.cl2 &lt;- MT |&gt; kppm(trend = ~ y, clusters = &quot;Thomas&quot;) model.cl2 ## Inhomogeneous cluster point process model ## Fitted to point pattern dataset &#39;MT&#39; ## Fitted by minimum contrast ## Summary statistic: inhomogeneous K-function ## ## Log intensity: ~y ## ## Fitted trend coefficients: ## (Intercept) y ## 6.894933 -1.486252 ## ## Cluster model: Thomas process ## Fitted cluster parameters: ## kappa scale ## 26.955877 0.053585 ## Mean cluster size: [pixel image] ## ## Cluster strength: phi = 1.028 ## Sibling probability: psib = 0.5069 This is an inhomogeneous cluster point process model. The logarithm of the intensity depends on y (Log intensity: ~y). The fitted trend coefficient is negative as expected, since there are fewer trees as you move north (increasing y direction). There is one spatial unit in the north-south direction so you interpret this coefficient to mean there are 77% fewer trees in the north than in the south. The 77% comes from the formula 1 - exp(-1.486) = .77 The average number of clusters (kappa) is higher at about 27 (it was 22 with the stationary model). The cluster scale parameter (sigma), indicating the characteristic size of the cluster (in distance units) is smaller at .0536. That makes sense since some of the event-to-event distances are accounted for by the trend term Simulate data using the new model and compare the inhomogeneous \\(K\\) function between the simulations and the observed data model.cl2 |&gt; envelope(fun = Kinhom, nsim = 99, correction = &#39;border&#39;) |&gt; plot(legend = FALSE) ## Generating 99 simulated realisations of fitted cluster model ... ## 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, ## 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, ## 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99. ## ## Done. The black line falls within the gray band and the gray band is narrower than the simulations using the homogeneous cluster model If the intensity of events depends on spatial location as it does with the maple trees you can include a trend and covariate term in the model For a trend term, the formula ~ x corresponds to a spatial trend of the form \\(\\lambda(x) = \\exp(a + bx)\\), while ~ x + y corresponds to \\(\\lambda(x, y) = \\exp(a + bx + cy)\\) where x, y are the spatial coordinates. For a covariates, the formula is ~ covariate1 + covariate2 Consider the bei data from the {spatstat} package containing the locations of 3605 trees in a tropical rain forest. bei |&gt; plot() Accompanied by covariate data giving the elevation (altitude) and slope of elevation in the study region. The data bei.extra is a list object containing two pixel images, elev (elevation in meters) and grad (norm of elevation gradient). These pixel images are objects of class im, see im.object. bei.extra |&gt; image() Compute and plot the \\(L\\) function on the ppp object bei bei |&gt; envelope(fun = Lest, nsim = 39, global = TRUE, correction = &quot;border&quot;) |&gt; plot(legend = FALSE) ## Generating 39 simulations of CSR ... ## 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39. ## ## Done. There is significant clustering indicated by the black line sitting far above the CSR line. There are more trees in the vicinity of other trees than expected by chance But how much of the clustering is due to variations in terrain? You start by fitting a model that includes elevation and gradient as covariates without clustering. This is done with the trend = argument naming the image variables and including the argument covariates = indicating a data frame or, in this case, a list whose entries are image functions model.ppm1 &lt;- bei |&gt; ppm(trend = ~ elev + grad, covariates = bei.extra) Check to see if elevation and gradient as explanatory variables are significant in the model. model.ppm1 |&gt; summary() ## Point process model ## Fitting method: maximum likelihood (Berman-Turner approximation) ## Model was fitted using glm() ## Algorithm converged ## Call: ## ppm.ppp(Q = bei, trend = ~elev + grad, covariates = bei.extra) ## Edge correction: &quot;border&quot; ## [border correction distance r = 0 ] ## -------------------------------------------------------------------------------- ## Quadrature scheme (Berman-Turner) = data + dummy + weights ## ## Data pattern: ## Planar point pattern: 3604 points ## Average intensity 0.00721 points per square metre ## Window: rectangle = [0, 1000] x [0, 500] metres ## Window area = 5e+05 square metres ## Unit of length: 1 metre ## ## Dummy quadrature points: ## 130 x 130 grid of dummy points, plus 4 corner points ## dummy spacing: 7.692308 x 3.846154 metres ## ## Original dummy parameters: = ## Planar point pattern: 16904 points ## Average intensity 0.0338 points per square metre ## Window: rectangle = [0, 1000] x [0, 500] metres ## Window area = 5e+05 square metres ## Unit of length: 1 metre ## Quadrature weights: ## (counting weights based on 130 x 130 array of rectangular tiles) ## All weights: ## range: [1.64, 29.6] total: 5e+05 ## Weights on data points: ## range: [1.64, 14.8] total: 41000 ## Weights on dummy points: ## range: [1.64, 29.6] total: 459000 ## -------------------------------------------------------------------------------- ## FITTED : ## ## Nonstationary Poisson process ## ## ---- Intensity: ---- ## ## Log intensity: ~elev + grad ## Model depends on external covariates &#39;elev&#39; and &#39;grad&#39; ## Covariates provided: ## elev: im ## grad: im ## ## Fitted trend coefficients: ## (Intercept) elev grad ## -8.56355220 0.02143995 5.84646680 ## ## Estimate S.E. CI95.lo CI95.hi Ztest Zval ## (Intercept) -8.56355220 0.341113849 -9.23212306 -7.89498134 *** -25.104675 ## elev 0.02143995 0.002287866 0.01695581 0.02592408 *** 9.371155 ## grad 5.84646680 0.255781018 5.34514522 6.34778838 *** 22.857313 ## ## ----------- gory details ----- ## ## Fitted regular parameters (theta): ## (Intercept) elev grad ## -8.56355220 0.02143995 5.84646680 ## ## Fitted exp(theta): ## (Intercept) elev grad ## 1.909398e-04 1.021671e+00 3.460097e+02 The output shows that both elevation and elevation gradient are significant in explaining the spatial varying intensity of the trees Since the conditional intensity is on a log scale you interpret the elevation coefficient as follows: For a one meter increase in elevation the local spatial intensity increases by a amount equal to exp(.021) or 2% Check how well the model fits the data. Again this is done with the envelope() function using the model object as the first argument. E &lt;- model.ppm1 |&gt; envelope(fun = Lest, nsim = 39, correction = &quot;border&quot;, global = TRUE) ## Generating 78 simulated realisations of fitted Poisson model (39 to estimate ## the mean and 39 to calculate envelopes) ... ## 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, ## 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78. ## ## Done. E |&gt; plot(main = &quot;Inhomogeneous Poisson Model&quot;, legend = FALSE) You conclude that although elevation and elevation slope are significant in explaining the spatial distribution of trees, they do not explain the clustering An improvement is made by adding a cluster process to the model. This is done with the function kppm() model.ppm2 &lt;- bei |&gt; kppm(trend = ~ elev + grad, covariates = bei.extra, clusters = &quot;Thomas&quot;) E &lt;- model.ppm2 |&gt; envelope(Lest, nsim = 39, global = TRUE, correction = &quot;border&quot;) ## Generating 78 simulated realisations of fitted cluster model (39 to estimate ## the mean and 39 to calculate envelopes) ... ## 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, ## 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78. ## ## Done. E |&gt; plot(main = &quot;Clustered Inhomogeneous Model&quot;, legend = FALSE) The uncertainty band is much wider. The empirical curve fits inside the band so you conclude that an inhomogeneous cluster process is an adequate description of the point pattern data An example of a point process model in the wild The vast majority of tornadoes have winds of less than 60 m/s (120 mph). Violent tornadoes, with winds exceeding 90 m/s, are rare. Most of these potentially destructive and deadly tornadoes occur from rotating thunderstorms called supercells, with formation contingent on local (storm-scale) meteorological conditions The long-term risk of a tornado at a given location is assessed using historical records, however, the rarity of the most violent tornadoes make these rate estimates unstable. Here you use the more stable rate estimates from the larger set of less violent tornadoes to create more reliable estimates of violent tornado frequency For this exercise attention is restricted to tornadoes occurring in Kansas over the period 1954–2021 Torn.sf &lt;- sf::st_read(dsn = here::here(&quot;data&quot;, &quot;1950-2021-torn-initpoint&quot;)) |&gt; sf::st_transform(crs = 3082) |&gt; dplyr::filter(mag &gt;= 0, yr &gt;= 1954) |&gt; dplyr::mutate(EF = mag, EFf = as.factor(EF)) |&gt; dplyr::select(yr, EF, EFf) ## Reading layer `1950-2021-torn-initpoint&#39; from data source ## `/Users/jelsner/Desktop/ClassNotes/ASS-2023/data/1950-2021-torn-initpoint&#39; ## using driver `ESRI Shapefile&#39; ## Simple feature collection with 67558 features and 22 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: -163.53 ymin: 17.7212 xmax: -64.7151 ymax: 61.02 ## Geodetic CRS: WGS 84 W.sfc &lt;- USAboundaries::us_states(states = &quot;Kansas&quot;) |&gt; sf::st_transform(crs = sf::st_crs(Torn.sf)) |&gt; sf::st_geometry() Torn.sf &lt;- Torn.sf[W.sfc, ] Create a owin and ppp objects. Note that although you already subset by Kansas tornadoes above you need to subset on the ppp object to assign the KS boundary as the analysis window. KS.win &lt;- W.sfc |&gt; as.owin() T.ppp &lt;- Torn.sf[&quot;EF&quot;] |&gt; as.ppp() T.ppp &lt;- T.ppp[KS.win] summary(T.ppp) ## Marked planar point pattern: 4160 points ## Average intensity 1.927737e-08 points per square unit ## ## *Pattern contains duplicated points* ## ## Coordinates are given to 1 decimal place ## i.e. rounded to the nearest multiple of 0.1 units ## ## marks are numeric, of type &#39;double&#39; ## Summary: ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.0000 0.0000 0.0000 0.6137 1.0000 5.0000 ## ## Window: polygonal boundary ## single connected closed polygon with 169 vertices ## enclosing rectangle: [1317675.9, 1980294.8] x [7114969, 7458570] units ## (662600 x 343600 units) ## Window area = 2.15797e+11 square units ## Fraction of frame area: 0.948 There are 4160 tornadoes over the period with an average intensity of 193 per 100 square kilometer (multiply the average intensity in square meters by 10^10) Separate the point pattern data into non-violent tornadoes and violent tornadoes. The non-violent tornadoes include those with an EF rating of 0, 1, 2 or 3. The violent tornadoes include those with an EF rating of 4 or 5 NV.ppp &lt;- T.ppp |&gt; subset(marks &lt;= 3 &amp; marks &gt;= 0) |&gt; unmark() summary(NV.ppp) ## Planar point pattern: 4119 points ## Average intensity 1.908737e-08 points per square unit ## ## *Pattern contains duplicated points* ## ## Coordinates are given to 1 decimal place ## i.e. rounded to the nearest multiple of 0.1 units ## ## Window: polygonal boundary ## single connected closed polygon with 169 vertices ## enclosing rectangle: [1317675.9, 1980294.8] x [7114969, 7458570] units ## (662600 x 343600 units) ## Window area = 2.15797e+11 square units ## Fraction of frame area: 0.948 V.ppp &lt;- T.ppp |&gt; subset(marks &gt;= 4) |&gt; unmark() V.ppp |&gt; summary() ## Planar point pattern: 41 points ## Average intensity 1.899933e-10 points per square unit ## ## Coordinates are given to 1 decimal place ## i.e. rounded to the nearest multiple of 0.1 units ## ## Window: polygonal boundary ## single connected closed polygon with 169 vertices ## enclosing rectangle: [1317675.9, 1980294.8] x [7114969, 7458570] units ## (662600 x 343600 units) ## Window area = 2.15797e+11 square units ## Fraction of frame area: 0.948 The spatial intensity of the non-violent tornadoes is 191 per 100 sq km. The spatial intensity of the violent tornadoes is 1.9 per 100 square kilometer Plot the locations of the violent tornado events V.ppp |&gt; plot() Earlier we found that the spatial intensity of tornado reports was a function of distance to nearest city with fewer reports in rural areas So here you include this as an explanatory variable. Import the data, set the CRS, and transform the CRS to match that of the tornadoes. Exclude cities with fewer than 1000 people C.sf &lt;- USAboundaries::us_cities() |&gt; dplyr::filter(population &gt;= 1000) |&gt; sf::st_transform(crs = sf::st_crs(Torn.sf)) ## City populations for contemporary data come from the 2010 census. Then convert the simple feature data frame to a ppp object. Then subset the events by the analysis window (Kansas border). C.ppp &lt;- C.sf |&gt; as.ppp() ## Warning in as.ppp.sf(C.sf): only first attribute column is used for marks C.ppp &lt;- C.ppp[KS.win] |&gt; unmark() C.ppp |&gt; plot() Next create a distance map of the city locations using the distmap() function Zc &lt;- C.ppp |&gt; distmap() Zc |&gt; plot() The pixel values of the im object are distances is meters. Blue indicates locations that are less than 20 km from a city Interest lies with the distance to nearest non-violent tornado. You check to see if this might be a useful variable in a model so you make a distance map for the non-violent events and then use the rhohat() function Znv &lt;- NV.ppp |&gt; distmap() rhat &lt;- rhohat(V.ppp, Znv, adjust = 1.5, smoother = &quot;kernel&quot;, method = &quot;transform&quot;) dist &lt;- rhat$Znv rho &lt;- rhat$rho hi &lt;- rhat$hi lo &lt;- rhat$lo Rho.df &lt;- data.frame(dist = dist, rho = rho, hi = hi, lo = lo) library(ggplot2) ggplot(data = Rho.df) + geom_ribbon(mapping = aes(x = dist, ymin = lo, ymax = hi), alpha = .3) + geom_line(aes(x = dist, y = rho), col = &quot;black&quot;) + ylab(&quot;Spatial intensity of violent tornadoes&quot;) + xlab(&quot;Distance from nearest non-violent tornado (m)&quot;) + theme_minimal() This shows that regions that get non-violent tornadoes also see higher rates of violent tornadoes So the model should include two covariates (trend terms), distance to nearest city and distance to nearest non-violent tornado model.ppm1 &lt;- V.ppp |&gt; ppm(trend = ~ Zc + Znv, covariates = list(Zc = Zc, Znv = Znv)) model.ppm1 |&gt; summary() |&gt; coef() ## Estimate S.E. CI95.lo CI95.hi Ztest ## (Intercept) -2.080845e+01 3.685283e-01 -2.153075e+01 -2.008614e+01 *** ## Zc -3.215477e-05 1.119207e-05 -5.409083e-05 -1.021872e-05 ** ## Znv -2.202999e-04 8.562717e-05 -3.881260e-04 -5.247372e-05 * ## Zval ## (Intercept) -56.463636 ## Zc -2.872996 ## Znv -2.572780 As expected the model shows fewer violent tornadoes with increasing distance from the nearest city (negative coefficient on Zc) and fewer violent tornadoes with increasing distance from a non-violent tornado (negative coefficient on Znv) Since the spatial unit is meters the coefficient of -3.21e-05 is interpreted as a [1 - exp(-.0321)] * 100% or 3% decrease in violent tornado reports per kilometer of distance from a city. Similarly the coefficient on distance from nearest non-violent tornado is interpreted as a 23% decrease in violent tornado reports per kilometer of distance from nearest non-violent tornado Check if there is any residual nearest neighbor correlation E &lt;- model.ppm1 |&gt; envelope(fun = Kest, nsim = 39, global = TRUE) ## Generating 78 simulated realisations of fitted Poisson model (39 to estimate ## the mean and 39 to calculate envelopes) ... ## 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, ## 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78. ## ## Done. E |&gt; plot(main = &quot;Inhomogeneous Poisson Model&quot;, legend = FALSE) There appears to be a bit of regularity at smaller scales. The empirical curve (black line) falls slightly below the model (dashed red line). There are fewer nearby violent tornadoes than one would expect To see if this is statistically significant, you add an inhibition process to the model model.ppm2 &lt;- V.ppp |&gt; ppm(trend = ~ Zc + Znv, covariates = list(Zc = Zc, Znv = Znv), interaction = Strauss(r = 40000)) model.ppm2 |&gt; summary() |&gt; coef() ## Estimate S.E. CI95.lo CI95.hi Ztest ## (Intercept) -2.001094e+01 6.387255e-01 -2.126282e+01 -1.875906e+01 *** ## Zc -4.133027e-05 1.298394e-05 -6.677831e-05 -1.588222e-05 ** ## Znv -2.283128e-04 1.162982e-04 -4.562531e-04 -3.724924e-07 * ## Interaction -6.218391e-01 3.925683e-01 -1.391259e+00 1.475807e-01 ## Zval ## (Intercept) -31.329491 ## Zc -3.183185 ## Znv -1.963167 ## Interaction -1.584028 The interaction coefficient has a negative sign as expected from the above plot, but the standard error is relatively large so it is not statistically significant. The 95% uncertainty interval contains zero Remove the inhibition process and add a trend term in the east-west direction model.ppm3 &lt;- V.ppp |&gt; ppm(trend = ~ Zc + Znv + x, covariates = list(Zc = Zc, Znv = Znv)) model.ppm3 |&gt; summary() |&gt; coef() ## Estimate S.E. CI95.lo CI95.hi Ztest ## (Intercept) -2.382183e+01 1.891118e+00 -2.752836e+01 -2.011531e+01 *** ## Zc -2.275000e-05 1.257065e-05 -4.738803e-05 1.888027e-06 ## Znv -2.347550e-04 8.632146e-05 -4.039420e-04 -6.556808e-05 ** ## x 1.677877e-06 1.019845e-06 -3.209817e-07 3.676735e-06 ## Zval ## (Intercept) -12.596693 ## Zc -1.809771 ## Znv -2.719544 ## x 1.645228 There is a significant eastward trend but it appears to confound the distance to city term because the Zc term is no longer significant. Why is this? Settle on the first model as the best and generate simulated data from it model.ppm1 |&gt; simulate(nsim = 6) |&gt; plot() ## Generating 6 simulated patterns ...1, 2, 3, 4, 5, 6. plot(V.ppp) The model appears to due a good job simulating data that looks like the actual data Spatial logistic regression Spatial logistic regression is a popular model for point pattern data. The study domain is divided into a grid of cells; each cell is assigned the value one if it contains at least one event, and zero otherwise Then a logistic regression is a model for the presence probability \\(p = P(Y = 1)\\) as a function of explanatory variables \\(X\\) in the form \\[ \\log \\frac{p}{1-p} = \\beta X \\] where the left-hand side is the logit (log of the odds ratio) and the \\(\\beta\\) are the coefficients on the explanatory variables to be determined If your data are stored as ppp objects, a spatial logistic model can be fit directly using functions from the {spatstat} package Let’s look at an example from the package (a good strategy when learning a new technique) Consider the locations of 57 copper ore deposits (events) and 146 line segments representing geological ‘lineaments.’ Lineaments are geological fault lines Interest centers on being able to predict the probability of a copper ore from the distance to the fault line The data are stored as a list in copper. The list contains a ppp object for the ore deposits and a psp object for the lineaments data(copper) copper$SouthPoints |&gt; plot() copper$SouthLines |&gt; plot(add = TRUE) First rotate the events (points and lines) by 90 degrees in the anticlockwise direction and save them as separate objects. C &lt;- rotate(copper$SouthPoints, pi/2) L &lt;- rotate(copper$SouthLines, pi/2) C |&gt; plot() L |&gt; plot(add = TRUE) You summarize the planar point pattern data object C C |&gt; summary() ## Planar point pattern: 57 points ## Average intensity 0.01020691 points per square km ## ## Coordinates are given to 2 decimal places ## i.e. rounded to the nearest multiple of 0.01 km ## ## Window: rectangle = [-158.233, -0.19] x [-0.335, 35] km ## (158 x 35.34 km) ## Window area = 5584.45 square km ## Unit of length: 1 km There are 57 ore deposits over a region of size 5584 square km resulting in an intensity of about .01 ore deposits per square km. Next you create a distance map indicating the distance to the nearest fault line. This distance will be used as a covariate for a model of the probability of an ore deposit. D &lt;- L |&gt; distmap() D |&gt; plot() Spatial logistic regression models are fit with the slrm() function from the {spatstat} family of packages model.slr &lt;- slrm(C ~ D) model.slr ## Fitted spatial logistic regression model ## Formula: C ~ D ## Fitted coefficients: ## (Intercept) D ## -4.72337865 0.07811134 The model says that the odds of a copper ore deposit along a lineament (D = 0) is exp(-4.723) = .00888. This is slightly less than the overall intensity of .01 The model also says that for every one unit (one kilometer) increase in distance from a lineament the expected change in the log odds is .0781 [exp(.0781) = 1.0812] or an 8.1% increase in the odds. Ore deposits are more likely between the lineaments (fault) The fitted method produces an image (raster) of the window giving the local probability of an ore deposit. Values are the probability of finding an ore deposit in each pixel model.slr |&gt; fitted() |&gt; plot() C |&gt; plot(add = TRUE) As we saw with the LGCP model, integrating (summing) the predictions over the domain area equals the abundance (number of ore deposits) model.slr |&gt; fitted() |&gt; sum() ## [1] 57 See https://r-spatial.org/book/12-Interpolation.html "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
