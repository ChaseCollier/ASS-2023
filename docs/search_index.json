[["tuesday-february-7-2023.html", "Tuesday February 7, 2023 Mapping using functions from the {ggplot2} package Mapping using functions from the {tmap} package Creating an interactive map Isolines and isobands Hillshape and colors with tidyterra Visualizing spatial data Adding an inset map", " Tuesday February 7, 2023 “Maps invest information with meaning by translating it into visual form.” – Susan Schulten Mapping using functions from the {ggplot2} package The {ggplot2} package has supports sf objects for making maps through the function geom_sf(). An initial ggplot() function is followed by one or more layers that are added with + symbol. The layers begin with geom_ (or stat_) For example, consider the objects nz and nz_height from the {spData} package, where nz is a simple feature data frame from the New Zealand census with information about the area, population, and income in the country’s 16 administrative regions str(spData::nz) ## Classes &#39;sf&#39; and &#39;data.frame&#39;: 16 obs. of 7 variables: ## $ Name : chr &quot;Northland&quot; &quot;Auckland&quot; &quot;Waikato&quot; &quot;Bay of Plenty&quot; ... ## $ Island : chr &quot;North&quot; &quot;North&quot; &quot;North&quot; &quot;North&quot; ... ## $ Land_area : num 12501 4942 23900 12071 8386 ... ## $ Population : num 175500 1657200 460100 299900 48500 ... ## $ Median_income: int 23400 29600 27900 26200 24400 26100 29100 25000 32700 26900 ... ## $ Sex_ratio : num 0.942 0.944 0.952 0.928 0.935 ... ## $ geom :List of 16 ## ..$ :List of 1 ## .. ..$ :List of 1 ## .. .. ..$ : num [1:68, 1:2] 1745493 1740539 1733165 1720197 1709110 ... ## .. ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;MULTIPOLYGON&quot; &quot;sfg&quot; ## ..$ :List of 3 ## .. ..$ :List of 1 ## .. .. ..$ : num [1:50, 1:2] 1803822 1791443 1790082 1781819 1776591 ... ## .. ..$ :List of 1 ## .. .. ..$ : num [1:13, 1:2] 1815954 1818016 1823327 1822800 1828379 ... ## .. ..$ :List of 1 ## .. .. ..$ : num [1:5, 1:2] 1793982 1791257 1784280 1781831 1793982 ... ## .. ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;MULTIPOLYGON&quot; &quot;sfg&quot; ## ..$ :List of 1 ## .. ..$ :List of 1 ## .. .. ..$ : num [1:105, 1:2] 1860345 1857808 1850511 1848327 1850061 ... ## .. ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;MULTIPOLYGON&quot; &quot;sfg&quot; ## ..$ :List of 1 ## .. ..$ :List of 1 ## .. .. ..$ : num [1:69, 1:2] 2049387 2051016 2040276 2040255 2046969 ... ## .. ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;MULTIPOLYGON&quot; &quot;sfg&quot; ## ..$ :List of 1 ## .. ..$ :List of 1 ## .. .. ..$ : num [1:45, 1:2] 2024489 2019037 2016277 2004167 2004512 ... ## .. ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;MULTIPOLYGON&quot; &quot;sfg&quot; ## ..$ :List of 1 ## .. ..$ :List of 1 ## .. .. ..$ : num [1:72, 1:2] 2024489 2024126 2032576 2025489 2023582 ... ## .. ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;MULTIPOLYGON&quot; &quot;sfg&quot; ## ..$ :List of 1 ## .. ..$ :List of 1 ## .. .. ..$ : num [1:35, 1:2] 1740438 1743867 1755759 1761828 1758062 ... ## .. ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;MULTIPOLYGON&quot; &quot;sfg&quot; ## ..$ :List of 1 ## .. ..$ :List of 1 ## .. .. ..$ : num [1:82, 1:2] 1866732 1868949 1865829 1869099 1868021 ... ## .. ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;MULTIPOLYGON&quot; &quot;sfg&quot; ## ..$ :List of 1 ## .. ..$ :List of 1 ## .. .. ..$ : num [1:49, 1:2] 1881590 1875693 1871588 1865559 1861255 ... ## .. ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;MULTIPOLYGON&quot; &quot;sfg&quot; ## ..$ :List of 1 ## .. ..$ :List of 1 ## .. .. ..$ : num [1:120, 1:2] 1557042 1554239 1546356 1537142 1528824 ... ## .. ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;MULTIPOLYGON&quot; &quot;sfg&quot; ## ..$ :List of 1 ## .. ..$ :List of 1 ## .. .. ..$ : num [1:109, 1:2] 1686902 1679996 1673699 1657488 1655263 ... ## .. ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;MULTIPOLYGON&quot; &quot;sfg&quot; ## ..$ :List of 1 ## .. ..$ :List of 1 ## .. .. ..$ : num [1:95, 1:2] 1335205 1336956 1325903 1327166 1325039 ... ## .. ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;MULTIPOLYGON&quot; &quot;sfg&quot; ## ..$ :List of 4 ## .. ..$ :List of 1 ## .. .. ..$ : num [1:102, 1:2] 1229078 1221427 1217551 1219439 1214300 ... ## .. ..$ :List of 1 ## .. .. ..$ : num [1:26, 1:2] 1207704 1216155 1218478 1229730 1229998 ... ## .. ..$ :List of 1 ## .. .. ..$ : num [1:7, 1:2] 1107047 1110194 1111405 1108801 1101068 ... ## .. ..$ :List of 1 ## .. .. ..$ : num [1:6, 1:2] 1125376 1124814 1128290 1125420 1118817 ... ## .. ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;MULTIPOLYGON&quot; &quot;sfg&quot; ## ..$ :List of 1 ## .. ..$ :List of 1 ## .. .. ..$ : num [1:58, 1:2] 1616643 1624866 1620946 1625383 1614073 ... ## .. ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;MULTIPOLYGON&quot; &quot;sfg&quot; ## ..$ :List of 1 ## .. ..$ :List of 1 ## .. .. ..$ : num [1:13, 1:2] 1624866 1616643 1618569 1626024 1627133 ... ## .. ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;MULTIPOLYGON&quot; &quot;sfg&quot; ## ..$ :List of 2 ## .. ..$ :List of 1 ## .. .. ..$ : num [1:54, 1:2] 1686902 1679241 1667754 1661737 1659683 ... ## .. ..$ :List of 1 ## .. .. ..$ : num [1:8, 1:2] 1680804 1681037 1676303 1668530 1665079 ... ## .. ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;MULTIPOLYGON&quot; &quot;sfg&quot; ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;sfc_MULTIPOLYGON&quot; &quot;sfc&quot; ## ..- attr(*, &quot;precision&quot;)= num 0 ## ..- attr(*, &quot;crs&quot;)=List of 2 ## .. ..$ input: chr &quot;EPSG:2193&quot; ## .. ..$ wkt : chr &quot;PROJCS[\\&quot;NZGD2000 / New Zealand Transverse Mercator 2000\\&quot;,\\n GEOGCS[\\&quot;NZGD2000\\&quot;,\\n DATUM[\\&quot;New_Zeal&quot;| __truncated__ ## .. ..- attr(*, &quot;class&quot;)= chr &quot;crs&quot; ## ..- attr(*, &quot;n_empty&quot;)= int 0 ## ..- attr(*, &quot;bbox&quot;)= &#39;bbox&#39; Named num [1:4] 1090144 4748537 2089533 6191874 ## .. ..- attr(*, &quot;names&quot;)= chr [1:4] &quot;xmin&quot; &quot;ymin&quot; &quot;xmax&quot; &quot;ymax&quot; ## - attr(*, &quot;sf_column&quot;)= chr &quot;geom&quot; ## - attr(*, &quot;agr&quot;)= Factor w/ 3 levels &quot;constant&quot;,&quot;aggregate&quot;,..: NA NA NA NA NA NA ## ..- attr(*, &quot;names&quot;)= chr [1:6] &quot;Name&quot; &quot;Island&quot; &quot;Land_area&quot; &quot;Population&quot; ... The simple feature column (sfc) is labeled geom and the geometry type is polygon. And spData::nz_height is a simple feature data frame containing elevations of specific high points (peaks) in the country. str(spData::nz_height) ## Classes &#39;sf&#39; and &#39;data.frame&#39;: 101 obs. of 3 variables: ## $ t50_fid : int 2353944 2354404 2354405 2369113 2362630 2362814 2362817 2363991 2363993 2363994 ... ## $ elevation: int 2723 2820 2830 3033 2749 2822 2778 3004 3114 2882 ... ## $ geometry :List of 101 ## ..$ : &#39;XY&#39; num 1204143 5049971 ## ..$ : &#39;XY&#39; num 1234725 5048309 ## ..$ : &#39;XY&#39; num 1235915 5048745 ## ..$ : &#39;XY&#39; num 1259702 5076570 ## ..$ : &#39;XY&#39; num 1378170 5158491 ## ..$ : &#39;XY&#39; num 1389460 5168749 ## ..$ : &#39;XY&#39; num 1390166 5169466 ## ..$ : &#39;XY&#39; num 1372357 5172729 ## ..$ : &#39;XY&#39; num 1372062 5173236 ## ..$ : &#39;XY&#39; num 1372810 5173419 ## ..$ : &#39;XY&#39; num 1372579 5173989 ## ..$ : &#39;XY&#39; num 1373264 5175442 ## ..$ : &#39;XY&#39; num 1373796 5174144 ## ..$ : &#39;XY&#39; num 1373955 5174231 ## ..$ : &#39;XY&#39; num 1373984 5175228 ## ..$ : &#39;XY&#39; num 1374555 5175635 ## ..$ : &#39;XY&#39; num 1379994 5170215 ## ..$ : &#39;XY&#39; num 1380299 5170364 ## ..$ : &#39;XY&#39; num 1380770 5170805 ## ..$ : &#39;XY&#39; num 1381328 5171486 ## ..$ : &#39;XY&#39; num 1382336 5173201 ## ..$ : &#39;XY&#39; num 1382013 5174081 ## ..$ : &#39;XY&#39; num 1374899 5176232 ## ..$ : &#39;XY&#39; num 1374895 5176458 ## ..$ : &#39;XY&#39; num 1374183 5177165 ## ..$ : &#39;XY&#39; num 1374469 5176966 ## ..$ : &#39;XY&#39; num 1375422 5177253 ## ..$ : &#39;XY&#39; num 1378959 5178129 ## ..$ : &#39;XY&#39; num 1379050 5178750 ## ..$ : &#39;XY&#39; num 1378021 5178881 ## ..$ : &#39;XY&#39; num 1379527 5179093 ## ..$ : &#39;XY&#39; num 1379675 5178977 ## ..$ : &#39;XY&#39; num 1380093 5179167 ## ..$ : &#39;XY&#39; num 1380511 5179463 ## ..$ : &#39;XY&#39; num 1380900 5179688 ## ..$ : &#39;XY&#39; num 1382650 5180702 ## ..$ : &#39;XY&#39; num 1384281 5174133 ## ..$ : &#39;XY&#39; num 1384988 5174930 ## ..$ : &#39;XY&#39; num 1385529 5175778 ## ..$ : &#39;XY&#39; num 1390165 5170140 ## ..$ : &#39;XY&#39; num 1385677 5176517 ## ..$ : &#39;XY&#39; num 1385030 5177217 ## ..$ : &#39;XY&#39; num 1385697 5177261 ## ..$ : &#39;XY&#39; num 1385568 5180142 ## ..$ : &#39;XY&#39; num 1385707 5179981 ## ..$ : &#39;XY&#39; num 1383006 5181085 ## ..$ : &#39;XY&#39; num 1383486 5181270 ## ..$ : &#39;XY&#39; num 1384195 5181559 ## ..$ : &#39;XY&#39; num 1383924 5182220 ## ..$ : &#39;XY&#39; num 1383474 5182610 ## ..$ : &#39;XY&#39; num 1383456 5183108 ## ..$ : &#39;XY&#39; num 1357203 5151999 ## ..$ : &#39;XY&#39; num 1361593 5159139 ## ..$ : &#39;XY&#39; num 1362452 5159462 ## ..$ : &#39;XY&#39; num 1363319 5159970 ## ..$ : &#39;XY&#39; num 1365305 5168284 ## ..$ : &#39;XY&#39; num 1365716 5168777 ## ..$ : &#39;XY&#39; num 1365809 5168944 ## ..$ : &#39;XY&#39; num 1366291 5169207 ## ..$ : &#39;XY&#39; num 1368054 5169020 ## ..$ : &#39;XY&#39; num 1367135 5169692 ## ..$ : &#39;XY&#39; num 1369510 5166149 ## ..$ : &#39;XY&#39; num 1369178 5167611 ## ..$ : &#39;XY&#39; num 1369513 5168236 ## ..$ : &#39;XY&#39; num 1369318 5169132 ## ..$ : &#39;XY&#39; num 1369117 5169750 ## ..$ : &#39;XY&#39; num 1361266 5158749 ## ..$ : &#39;XY&#39; num 1369382 5168762 ## ..$ : &#39;XY&#39; num 1370181 5169698 ## ..$ : &#39;XY&#39; num 1368235 5169922 ## ..$ : &#39;XY&#39; num 1369252 5170239 ## ..$ : &#39;XY&#39; num 1369504 5171004 ## ..$ : &#39;XY&#39; num 1368939 5171945 ## ..$ : &#39;XY&#39; num 1369609 5171525 ## ..$ : &#39;XY&#39; num 1369227 5171811 ## ..$ : &#39;XY&#39; num 1369918 5171564 ## ..$ : &#39;XY&#39; num 1370144 5171638 ## ..$ : &#39;XY&#39; num 1370483 5171770 ## ..$ : &#39;XY&#39; num 1370422 5172432 ## ..$ : &#39;XY&#39; num 1369528 5173069 ## ..$ : &#39;XY&#39; num 1370492 5171944 ## ..$ : &#39;XY&#39; num 1370621 5173947 ## ..$ : &#39;XY&#39; num 1370624 5174185 ## ..$ : &#39;XY&#39; num 1371944 5173641 ## ..$ : &#39;XY&#39; num 1371403 5173122 ## ..$ : &#39;XY&#39; num 1371982 5173460 ## ..$ : &#39;XY&#39; num 1402489 5174996 ## ..$ : &#39;XY&#39; num 1404375 5184714 ## ..$ : &#39;XY&#39; num 1404384 5185038 ## ..$ : &#39;XY&#39; num 1436166 5197562 ## ..$ : &#39;XY&#39; num 1436552 5197471 ## ..$ : &#39;XY&#39; num 1438696 5200244 ## ..$ : &#39;XY&#39; num 1652788 5348984 ## ..$ : &#39;XY&#39; num 1654213 5349963 ## ..$ : &#39;XY&#39; num 1654899 5350463 ## ..$ : &#39;XY&#39; num 1654820 5351665 ## ..$ : &#39;XY&#39; num 1821014 5647971 ## ..$ : &#39;XY&#39; num 1820643 5648331 ## ..$ : &#39;XY&#39; num 1820660 5649488 ## .. [list output truncated] ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;sfc_POINT&quot; &quot;sfc&quot; ## ..- attr(*, &quot;precision&quot;)= num 0 ## ..- attr(*, &quot;bbox&quot;)= &#39;bbox&#39; Named num [1:4] 1204143 5048309 1822492 5650492 ## .. ..- attr(*, &quot;names&quot;)= chr [1:4] &quot;xmin&quot; &quot;ymin&quot; &quot;xmax&quot; &quot;ymax&quot; ## ..- attr(*, &quot;crs&quot;)=List of 2 ## .. ..$ input: chr &quot;EPSG:2193&quot; ## .. ..$ wkt : chr &quot;PROJCS[\\&quot;NZGD2000 / New Zealand Transverse Mercator 2000\\&quot;,\\n GEOGCS[\\&quot;NZGD2000\\&quot;,\\n DATUM[\\&quot;New_Zeal&quot;| __truncated__ ## .. ..- attr(*, &quot;class&quot;)= chr &quot;crs&quot; ## ..- attr(*, &quot;n_empty&quot;)= int 0 ## - attr(*, &quot;sf_column&quot;)= chr &quot;geometry&quot; ## - attr(*, &quot;agr&quot;)= Factor w/ 3 levels &quot;constant&quot;,&quot;aggregate&quot;,..: NA NA ## ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;t50_fid&quot; &quot;elevation&quot; The simple feature column is labeled geometry and the geometry type is point You make a choropleth map of the median income (Median_income) in the regions and add a layer indicating the location of the elevation peaks library(ggplot2) ggplot() + geom_sf(data = spData::nz, mapping = aes(fill = Median_income)) + geom_sf(data = spData::nz_height) + scale_x_continuous(breaks = c(170, 175)) The first use of geom_sf() takes the geometry column of the simple feature data frame spData::nz together with the mapping = argument and specifies filling the interior of the polygons with the values from the column labeled Medium_income in the simple feature data frame. The second use of geom_sf() takes the geometry column of spData::nz_height and maps the geometry type as points indicating the location of the highest peaks The geom_sf() function automatically plots the graticule (grid of latitude and longitude) with labels. The default ranges for the graticule can be overridden using scale_x_continuous(), scale_y_continuous() or coord_sf(datum = NA) A big advantage of using functions from {ggplot2} for mapping include a large community of users and many add-on packages Another example: the county land area by state in the U.S. The data is a simple feature data frame available in the {USAboundariesData} package at ropensci.org (not on CRAN) install.packages(&quot;USAboundariesData&quot;, repos = &quot;http://packages.ropensci.org&quot;, type = &quot;source&quot;) Here you extract the county borders in Florida then make a choropleth of the land area FLcounties.sf &lt;- USAboundaries::us_counties(states = &quot;FL&quot;) ggplot() + geom_sf(data = FLcounties.sf, mapping = aes(fill = aland)) Leaving off the mapping = argument will result in a map of the geometry ggplot() + geom_sf(data = FLcounties.sf) Example: Wildfires in the Apalachicola National Forest (ANF). Import the Florida wildfire data as a simple feature data frame called FL_Fires.sf and transform the native CRS to a Florida GDL Albers (EPSG 3086) if(!&quot;FL_Fires&quot; %in% list.files(here::here(&quot;data&quot;))){ download.file(&quot;http://myweb.fsu.edu/jelsner/temp/data/FL_Fires.zip&quot;, here::here(&quot;data&quot;,&quot;FL_Fires.zip&quot;)) unzip(here::here(&quot;data&quot;, &quot;FL_Fires.zip&quot;), exdir = here::here(&quot;data&quot;)) } FL_Fires.sf &lt;- sf::st_read(dsn = here::here(&quot;data&quot;, &quot;FL_Fires&quot;)) |&gt; sf::st_transform(crs = 3086) ## Reading layer `FL_Fires&#39; from data source ## `/Users/jameselsner/Desktop/ClassNotes/ASS-2023/data/FL_Fires&#39; ## using driver `ESRI Shapefile&#39; ## Simple feature collection with 90261 features and 37 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: -9750382 ymin: 2824449 xmax: -8908899 ymax: 3632749 ## Projected CRS: Mercator_2SP The data are start locations for 90,261 Florida wildfires over the period 1992-2015. Among other attributes each row (feature) gives the cause (STAT_CAU_1), discovery date (CONT_DA), and fire size class (A:G, small to large) Start with a bar chart showing the fire causes in order of frequency FL_Fires.sf |&gt; dplyr::group_by(STAT_CAU_1) |&gt; dplyr::summarize(nF = dplyr::n()) |&gt; dplyr::mutate(Cause = reorder(STAT_CAU_1, nF)) |&gt; ggplot() + geom_col(mapping = aes(x = nF, y = Cause)) Continue with a table showing the frequency of fires by size class table(FL_Fires.sf$FIRE_SIZE_) ## ## A B C D E F G ## 20262 50981 15394 2057 1035 406 126 Next, use the USAboundaries::us_counties() function to get county boundaries in Florida as a simple feature data frame. Transform the CRS to match the CRS of the wildfire simple feature. Then select on the name column and filter with name = \"Liberty\" to keep only the boundaries of Liberty County assign the result to the simple feature data frame named Liberty.sf FL.sf &lt;- USAboundaries::us_counties(states = &quot;FL&quot;, resolution = &quot;high&quot;) |&gt; sf::st_transform(crs = sf::st_crs(FL_Fires.sf)) Liberty.sf &lt;- FL.sf |&gt; dplyr::select(name) |&gt; dplyr::filter(name == &quot;Liberty&quot;) Make a map showing the boundaries of Florida and the boundaries of Liberty County ggplot() + geom_sf(data = FL.sf) + geom_sf(data = Liberty.sf, fill = &quot;green&quot;) Next use the function sf::st_intersection() to create a new simple feature data frame called LibertyFires.sf from the FL_Fires.sf simple feature data frame that contains only the lightning caused wildfires inside the Liberty County polygon LibertyFires.sf &lt;- FL_Fires.sf |&gt; sf::st_intersection(Liberty.sf) |&gt; dplyr::filter(STAT_CAU_1 == &quot;Lightning&quot;) ## Warning: attribute variables are assumed to be spatially constant throughout ## all geometries Finally, make a map showing the locations of the fires in Liberty County ggplot(data = Liberty.sf) + geom_sf() + geom_sf(data = LibertyFires.sf, color = &quot;orange&quot;) Mapping using functions from the {tmap} package There are other packages for making quick, nice maps in R I particularly like {tmap} because it is agnostic to the type of spatial data object. Simple feature data frames as well as {sp} and {terra} objects can be combined on a single map Functions in the {tmap} use the ‘grammar of graphics’ philosophy that separates the data frame from the aesthetics (how data are made visible). Functions translate the data into aesthetics. The aesthetics can include the location on a geographic map (defined by the geometry), color, and other visual components A map made with functions from {tmap} starts with the tmap::tm_shape() function that takes as input a spatial data frame. The function is followed by one or more layers such as tmap::tm_fill(), tmap::tm_dots(), tmap::tm_raster(), etc that defines how a property in the data gets translated to a visual component Consider again the New Zealand simple feature data frame (nz). To make a map of the region borders you first identify the spatial data frame with the tmap::tm_shape() function and then add a borders layer with the tmap::tm_borders() layer tmap::tm_shape(shp = spData::nz) + tmap::tm_borders() The function tmap::tm_shape() and its subsequent drawing layers (here tmap::tm_borders()) as a ‘group’. The data in the tmap::tm_shape() function must be a spatial object of class simple feature, raster, or an S4 class spatial object Compare with the {ggplot2} syntax ggplot(data = spData::nz) + geom_sf() With {ggplot2} you use the mapping = aes() argument to specify how to handle the non-geometric aesthetics. With the {tmap} you use a different function For example, here you use a fill layer (tmap::tm_fill()) instead of the borders layer tmap::tm_shape(spData::nz) + tmap::tm_fill() The polygons defining the boundaries are filled using the same gray color (default) as the borders so they disappear Here you first add the fill layer and then add a border layer tmap::tm_shape(spData::nz) + tmap::tm_fill(col = &#39;green&#39;) + tmap::tm_borders() Layers are added with the + operator and are functionally equivalent to adding a GIS layer You can assign the resulting map to an object. For example here you assign the map of New Zealand to the object map_nz map_nz &lt;- tmap::tm_shape(spData::nz) + tmap::tm_polygons() class(map_nz) ## [1] &quot;tmap&quot; The resulting object is of class tmap Additional spatial data are added to the map object with + tmap::tm_shape(new_object), where new_object is another spatial data frame the values of which are used to plot on top of the preceding layers When a new spatial data frame is added in this way, all subsequent aesthetic functions refer to it, until another spatial data frame is added For example, here you add an elevation layer to the New Zealand map. The elevation raster (spDataLarge::nz_elev) spatial data frame is in the {spDataLarge} package on GitHub The install_github() function from the {devtools} package is used to install packages on GitHub. GitHub is a company that provides hosting for software development version control using Git. Git is a version-control system for tracking changes in code during software development if(!require(devtools)) install.packages(pkgs = &quot;devtools&quot;, repos = &quot;http://cran.us.r-project.org&quot;) ## Loading required package: devtools ## Loading required package: usethis library(devtools) if(!require(spDataLarge)) install_github(repo = &quot;Nowosad/spDataLarge&quot;) ## Loading required package: spDataLarge library(spDataLarge) Next you identify the spatial data for the the new layer by adding tmap::tm_shape(nz_elev). Then add the raster layer with the tmap::tm_raster() function and set the transparency level to 70% (alpha = .7). ( map_nz1 &lt;- map_nz + tmap::tm_shape(spDataLarge::nz_elev) + tmap::tm_raster(alpha = .7) ) ## stars object downsampled to 877 by 1140 cells. See tm_shape manual (argument raster.downsample) You can see that the new map object, that you assign to map_nz1, builds on top of the existing map object map_nz by adding the raster layer spDataLarge::nz_elev representing elevation You can also create new layers with functions. For instance, a function like sf::st_union() operates on the geometry column of a simple feature data frame As an example, here you create a line string layer as a simple feature object using three geo-computation functions. You start by creating a union over all polygons (regions) with the sf::st_union() function applied to the spData::nz simple feature object. The result is a polygon defining the coastlines Then you buffer this polygon out to a distance of 22.2 km using the sf::st_buffer() function. The result is a single polygon defining the coastal boundary around the entire country Finally you change the polygon geometry to a line string geometry with the sf::st_cast() function To keep your code human-readable, you link these operations together with the pipe operator as follows ( nz_water.sfc &lt;- spData::nz |&gt; sf::st_union() |&gt; sf::st_buffer(dist = 22200) |&gt; sf::st_cast(to = &quot;LINESTRING&quot;) ) ## Geometry set for 1 feature ## Geometry type: LINESTRING ## Dimension: XY ## Bounding box: xmin: 1067944 ymin: 4726340 xmax: 2111732 ymax: 6214066 ## Projected CRS: NZGD2000 / New Zealand Transverse Mercator 2000 ## LINESTRING (1074909 4920220, 1074855 4920397, 1... The result is simple feature column. You then add the resulting sfc as a layer to the map ( map_nz2 &lt;- map_nz1 + tmap::tm_shape(nz_water.sfc) + tmap::tm_lines() ) ## stars object downsampled to 877 by 1140 cells. See tm_shape manual (argument raster.downsample) Finally, you create a layer representing the country elevation high points (stored in the object spData::nz_height) onto the map_nz2 object with tmap::tm_dots() function ( map_nz3 &lt;- map_nz2 + tmap::tm_shape(spData::nz_height) + tmap::tm_dots() ) ## stars object downsampled to 877 by 1140 cells. See tm_shape manual (argument raster.downsample) Map layout and faceting Layout functions help create a cartographic map. Elements include the title, the scale bar, margins, aspect ratios, etc. For example, here elements such as a north arrow and a scale bar are added with tmap::tm_compass() and tmap::tm_scale_bar(), respectively and the tmap::tm_layout() function is used to add the title and background color map_nz + tmap::tm_compass(type = &quot;8star&quot;, position = c(&quot;left&quot;, &quot;top&quot;)) + tmap::tm_scale_bar(breaks = c(0, 100, 200), text.size = 1) + tmap::tm_layout(title = &quot;New Zealand&quot;, bg.color = &quot;lightblue&quot;) Putting two or more maps with the same scale side by side allows for comparisons. You can see how spatial relationships change with respect to another variable Creating small multiples of the same map with different variables is called ‘faceting’ Consider the simple feature data frame World. Make the data frame accessible to this session with the data() function library(tmap) data(World) head(World) ## Simple feature collection with 6 features and 15 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: -73.41544 ymin: -55.25 xmax: 75.15803 ymax: 42.68825 ## Geodetic CRS: WGS 84 ## iso_a3 name sovereignt continent ## 1 AFG Afghanistan Afghanistan Asia ## 2 AGO Angola Angola Africa ## 3 ALB Albania Albania Europe ## 4 ARE United Arab Emirates United Arab Emirates Asia ## 5 ARG Argentina Argentina South America ## 6 ARM Armenia Armenia Asia ## area pop_est pop_est_dens economy ## 1 652860.00 [km^2] 28400000 43.50090 7. Least developed region ## 2 1246700.00 [km^2] 12799293 10.26654 7. Least developed region ## 3 27400.00 [km^2] 3639453 132.82675 6. Developing region ## 4 71252.17 [km^2] 4798491 67.34519 6. Developing region ## 5 2736690.00 [km^2] 40913584 14.95003 5. Emerging region: G20 ## 6 28470.00 [km^2] 2967004 104.21510 6. Developing region ## income_grp gdp_cap_est life_exp well_being footprint inequality ## 1 5. Low income 784.1549 59.668 3.8 0.79 0.4265574 ## 2 3. Upper middle income 8617.6635 NA NA NA NA ## 3 4. Lower middle income 5992.6588 77.347 5.5 2.21 0.1651337 ## 4 2. High income: nonOECD 38407.9078 NA NA NA NA ## 5 3. Upper middle income 14027.1261 75.927 6.5 3.14 0.1642383 ## 6 4. Lower middle income 6326.2469 74.446 4.3 2.23 0.2166481 ## HPI geometry ## 1 20.22535 MULTIPOLYGON (((61.21082 35... ## 2 NA MULTIPOLYGON (((16.32653 -5... ## 3 36.76687 MULTIPOLYGON (((20.59025 41... ## 4 NA MULTIPOLYGON (((51.57952 24... ## 5 35.19024 MULTIPOLYGON (((-65.5 -55.2... ## 6 25.66642 MULTIPOLYGON (((43.58275 41... The simple feature data frame has socio-economic indicators by country. Each row is a country Further, consider the simple feature data frame spData::urban_agglomerations. The data frame is from the United Nations population division with projections up to 2050 for the top 30 largest areas by population at 5 year intervals (in long form) The geometries are points indicating the location of the largest urban metro areas. You create a new data frame keeping only the years 1970, 1990, 2010, and 2030 by using the dplyr::filter() function urb_1970_2030 &lt;- spData::urban_agglomerations |&gt; dplyr::filter(year %in% c(1970, 1990, 2010, 2030)) Again, the operator %in% acts like a recursive or. If year == 1970 or year == 1990, … The first map layer is the country polygons from the World data frame and the second layer is city locations from the urb_1970_2030 data frame using the tmap::tm_symbols() function Symbol size is scaled by the variable population_millions. Finally you group by the variable year with the tmap::tm_facets() function to produce a four-panel set of maps tmap::tm_shape(World) + tmap::tm_polygons() + tmap::tm_shape(urb_1970_2030) + tmap::tm_symbols(col = &quot;black&quot;, border.col = &quot;white&quot;, size = &quot;population_millions&quot;) + tmap::tm_facets(by = &quot;year&quot;, nrow = 2, free.coords = FALSE) The above code chunk demonstrates key features of faceted maps created with functions from the {tmap} package Shapes that do not have a facet variable are repeated (the countries in World in this case) The by = argument which varies depending on a variable (year in this case) nrow/ncol setting specifying the number of rows (and columns) that facets should be arranged into The free.coords = argument specifies whether each map has its own bounding box Small multiples are also generated by assigning more than one value to one of the aesthetic arguments For example here you map the happiness index (HPI) on one map and gross domestic product per person (gdp_cap_est) on another map. Both variables are in the World data frame tmap::tm_shape(World) + tmap::tm_polygons(col = c(&quot;HPI&quot;, &quot;gdp_cap_est&quot;), style = c(&quot;pretty&quot;, &quot;kmeans&quot;), palette = list(&quot;RdYlGn&quot;, &quot;Purples&quot;), title = c(&quot;Happy Planet Index&quot;, &quot;GDP per capita&quot;)) Note that the variable names must be in quotes (e.g., “HPI”). This is different than variables named in the {ggplot2} functions The maps are identical except for the variable being plotted. All arguments of the layer functions can be vectorized, one for each map. Arguments that normally take a vector, such as palette =, are placed in a list() Multiple map objects can also be arranged in a single plot with the tmap::tmap_arrange() function. Here you create two separate maps then arrange them map1 &lt;- tmap::tm_shape(World) + tmap::tm_polygons(col = &quot;HPI&quot;, style = &quot;pretty&quot;, palette = &quot;RdYlGn&quot;, title = &quot;Happy Planet Index&quot;) map2 &lt;- tmap::tm_shape(World) + tmap::tm_polygons(col = &quot;gdp_cap_est&quot;, style = &quot;kmeans&quot;, palette = &quot;Purples&quot;, title = &quot;GDP per capita&quot;) tmap::tmap_arrange(map1, map2) Example: COVID19 vaccinations by state on Saturday February 6, 2021. Get the data. f &lt;- &quot;https://raw.githubusercontent.com/owid/covid-19-data/e2da3a49250481a8a22f993ee5c3731111ba6958/scripts/scripts/vaccinations/us_states/input/cdc_data_2021-02-06.csv&quot; vax.df &lt;- readr::read_csv(f) ## Rows: 65 Columns: 18 ## ── Column specification ──────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (3): Location, ShortName, LongName ## dbl (14): Census2019, Doses_Distributed, Doses_Administered, Dist_Per_100K,... ## date (1): Date ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. Get a US census map from the {USAboundaries} package. Rename the state name column (name) to LongName. vax.sf &lt;- USAboundaries::us_states() |&gt; dplyr::filter(!name %in% c(&quot;District of Columbia&quot;, &quot;Puerto Rico&quot;, &quot;Hawaii&quot;, &quot;Alaska&quot;)) |&gt; dplyr::rename(LongName = name) Join the COVID data frame with the simple feature data frame from the census. Then make a map showing the doses administered per 100K people. vax.sf &lt;- vax.sf |&gt; dplyr::left_join(vax.df, by = &quot;LongName&quot;) tmap::tm_shape(vax.sf) + tmap::tm_fill(col = &quot;Admin_Per_100K&quot;, title = &quot;Per 100K&quot; ) + tmap::tm_borders(col = &quot;gray70&quot;) + tmap::tm_layout(legend.outside = TRUE) Creating an interactive map A nice feature of the {tmap} package is that you can create an interactive map using the same code used to create a static map From earlier you created a map of the county borders in Florida using the following code tmap::tm_shape(FLcounties.sf) + tmap::tm_borders() By default the map gets rendered directly to the Rmd screen or to the Plots window as a static image. To change the default to an interactive image you set the render mode to \"view\" in the tmap::tmap_mode() function Here you repeat the county boundary map after specifying the render mode tmap::tmap_mode(&quot;view&quot;) ## tmap mode set to interactive viewing tmap::tm_shape(FLcounties.sf) + tmap::tm_borders() The county borders from your spatial data frame are overlaid on zoomable Leaflet tiles You change the underlying layers by to OpenStreetMap by clicking on the layering symbol With the interactive (“view”) mode turned on, all maps produced with {tmap} launch as zoom-able HTML. This feature includes the ability to specify the base map with tmap::tm_basemap() (or tmap::tmap_options()) as demonstrated here tmap::tm_basemap(server = &quot;OpenTopoMap&quot;) + map_nz You can also create interactive maps with the tmap::tmap_leaflet() function The view mode in {tmap} also works with faceted plots. The argument sync in tmap::tm_facets() is used to produce multiple maps with synchronized zoom and pan settings world_coffee &lt;- dplyr::left_join(spData::world, spData::coffee_data, by = &quot;name_long&quot;) tmap::tm_shape(world_coffee) + tmap::tm_polygons(c(&quot;coffee_production_2016&quot;, &quot;coffee_production_2017&quot;)) + tmap::tm_facets(nrow = 1, sync = TRUE) Change the view mode back to a static plot. tmap::tmap_mode(&quot;plot&quot;) ## tmap mode set to plotting Isolines and isobands The {isoband} package has functions to generate contour lines (isolines) and contour polygons (isobands) from regularly spaced grids containing elevation (or other) data. library(isoband) The two main functions are isolines() and isobands(). They return a list of isolines/isobands for each isolevel specified Each isoline/isoband consists of vectors of x and y coordinates, as well as a vector of ids specifying which sets of coordinates should be connected. This format can be handed directly to grid.polyline()/grid.path() for drawing. However, you can also convert the output to spatial features and draw with functions from {ggplot2}. Consider the following matrix ( m &lt;- matrix(c(0, 0, 0, 0, 0, 0, 1, 2, 1, 0, 0, 1, 2, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0), 5, 5, byrow = TRUE) ) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 0 0 0 0 0 ## [2,] 0 1 2 1 0 ## [3,] 0 1 2 0 0 ## [4,] 0 1 0 1 0 ## [5,] 0 0 0 0 0 Apply the function isolines() specifying the x locations, y locations, and the levels ( isoband::isolines(x = 1:ncol(m), y = 1:nrow(m), z = m, levels = .5) ) ## $`0.5` ## $`0.5`$x ## [1] 4.00 3.50 3.00 2.50 2.00 1.50 1.50 1.50 2.00 3.00 4.00 4.50 4.00 3.75 4.00 ## [16] 4.50 4.00 ## ## $`0.5`$y ## [1] 4.50 4.00 3.75 4.00 4.50 4.00 3.00 2.00 1.50 1.25 1.50 2.00 2.50 3.00 3.50 ## [16] 4.00 4.50 ## ## $`0.5`$id ## [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ## ## ## attr(,&quot;class&quot;) ## [1] &quot;isolines&quot; &quot;iso&quot; Apply the function isobands() specifying the x locations, y locations, the low and high levels ( isoband::isobands(x = 1:ncol(m), y = 1:nrow(m), z = m, levels_low = .5, levels_high = 1.5) ) ## $`0.5:1.5` ## $`0.5:1.5`$x ## [1] 2.50 2.00 1.50 1.50 1.50 2.00 3.00 4.00 4.50 4.00 3.75 4.00 4.50 4.00 3.50 ## [16] 3.00 3.00 3.25 3.50 3.00 2.50 2.50 ## ## $`0.5:1.5`$y ## [1] 4.00 4.50 4.00 3.00 2.00 1.50 1.25 1.50 2.00 2.50 3.00 3.50 4.00 4.50 4.00 ## [16] 3.75 3.25 3.00 2.00 1.75 2.00 3.00 ## ## $`0.5:1.5`$id ## [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 ## ## ## attr(,&quot;class&quot;) ## [1] &quot;isobands&quot; &quot;iso&quot; The function plot_iso() is a convenience function for debugging and testing plot_iso(m, vlo = .5, vhi = 1.5) Let’s calculate isolines and isobands for the volcano dataset, convert to {sf}, and plot with {ggplot2} library(ggplot2) suppressWarnings(library(sf)) ## Linking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE m &lt;- volcano b &lt;- isobands((1:ncol(m))/(ncol(m)+1), (nrow(m):1)/(nrow(m)+1), m, 10*(9:19), 10*(10:20)) l &lt;- isolines((1:ncol(m))/(ncol(m)+1), (nrow(m):1)/(nrow(m)+1), m, 10*(10:19)) bands &lt;- iso_to_sfg(b) data_bands &lt;- st_sf( level = 1:length(bands), geometry = st_sfc(bands) ) lines &lt;- iso_to_sfg(l) data_lines &lt;- st_sf( level = 2:(length(lines)+1), geometry = st_sfc(lines) ) ggplot() + geom_sf(data = data_bands, aes(fill = level), color = NA, alpha = 0.7) + geom_sf(data = data_lines, color = &quot;black&quot;) + scale_fill_viridis_c(guide = &quot;none&quot;) + coord_sf(expand = FALSE) Hillshape and colors with tidyterra https://dieghernan.github.io/202210_tidyterra-hillshade/#r_bloggers Get the data. Bulgarian elevation mydir &lt;- here::here(&quot;data&quot;) r_init &lt;- geodata::elevation_30s(&quot;BGR&quot;, path = mydir) r_init ## class : SpatRaster ## dimensions : 396, 792, 1 (nrow, ncol, nlyr) ## resolution : 0.008333333, 0.008333333 (x, y) ## extent : 22.2, 28.8, 41.1, 44.4 (xmin, xmax, ymin, ymax) ## coord. ref. : lon/lat WGS 84 (EPSG:4326) ## source : BGR_elv_msk.tif ## name : BGR_elv_msk ## min value : -7 ## max value : 2738 Rename BGR_elv_msk to alt and set the minimum to zero using the parallel max function pmax() names(r_init) &lt;- &quot;alt&quot; r &lt;- r_init |&gt; tidyterra::mutate(alt = pmax(0, alt)) r ## class : SpatRaster ## dimensions : 396, 792, 1 (nrow, ncol, nlyr) ## resolution : 0.008333333, 0.008333333 (x, y) ## extent : 22.2, 28.8, 41.1, 44.4 (xmin, xmax, ymin, ymax) ## coord. ref. : lon/lat WGS 84 (EPSG:4326) ## source(s) : memory ## name : alt ## min value : 0 ## max value : 2738 Quick plot library(ggplot2) autoplot(r) + theme_minimal() {tidyterra} provides additional gradients whose colors are placed unevenly with the goal of providing a better understanding of the maps grad_hypso &lt;- tidyterra::hypso.colors2(10, &quot;dem_poster&quot;) autoplot(r) + scale_fill_gradientn(colours = grad_hypso, na.value = NA) ## Scale for fill is already present. ## Adding another scale for fill, which will replace the existing scale. In contrast, a regular gradient would just interpolate colors assuming that the distance among colors is the same Next step is to calculate the hillshade. You want to create is a layer that approximates the potential ‘texture’ of the surface based on the elevation and the sun position. This is done with the terra::terrain() and terra::shade() functions slope &lt;- r |&gt; terra::terrain(&quot;slope&quot;, unit = &quot;radians&quot;) aspect &lt;- r |&gt; terra::terrain(&quot;aspect&quot;, unit = &quot;radians&quot;) hill &lt;- terra::shade(slope, aspect, 30, 270) names(hill) &lt;- &quot;shades&quot; Start with a gray palette. library(tidyterra) ## ## Attaching package: &#39;tidyterra&#39; ## The following object is masked from &#39;package:stats&#39;: ## ## filter pal_greys &lt;- hcl.colors(1000, &quot;Grays&quot;) ( hill_plot &lt;- ggplot() + geom_spatraster(data = hill) + scale_fill_gradientn(colors = pal_greys, na.value = NA) ) Now blend the hillshade layer with the altitude layer using some level of alpha on the upper layer r_limits &lt;- terra::minmax(r) |&gt; as.vector() # Rounded to lower and upper 500 r_limits &lt;- c(floor(r_limits[1] / 500), ceiling(r_limits[2] / 500)) * 500 base_plot &lt;- hill_plot + geom_spatraster(data = r, maxcell = Inf) + scale_fill_hypso_tint_c( limits = r_limits, palette = &quot;dem_poster&quot;, alpha = 0.4, labels = scales::label_comma(), # For the legend I use custom breaks breaks = c( seq(0, 500, 100), seq(750, 1500, 250), 2000 ) ) ## Scale for fill is already present. ## Adding another scale for fill, which will replace the existing scale. base_plot Visualizing spatial data https://nrennie.rbind.io/blog/2022-12-17-r-packages-for-visualising-spatial-data/ Adding an inset map An inset map puts the geographic study area into context. Here you create a map of the central part of New Zealand’s Southern Alps. The inset map shows where the main map is in relation to the rest of New Zealand The first step is to define the area of interest. Here it is done by creating a new spatial object nz_region using the sf::st_bbox() function and the sf::st_as_sfc() to make it a simple feature column nz_region &lt;- sf::st_bbox(c(xmin = 1340000, xmax = 1450000, ymin = 5130000, ymax = 5210000), crs = sf::st_crs(spData::nz_height)) |&gt; sf::st_as_sfc() Next create a base map showing New Zealand’s Southern Alps area. This is the closeup view of where the most important message is stated. The region is clipped to the simple feature column nz_region created above. The layers include a raster of elevations and locations of high points. A scale bar is included ( nz_height_map &lt;- tmap::tm_shape(spDataLarge::nz_elev, bbox = nz_region) + tmap::tm_raster(style = &quot;cont&quot;, palette = &quot;YlGn&quot;, legend.show = TRUE) + tmap::tm_shape(spData::nz_height) + tmap::tm_symbols(shape = 2, col = &quot;red&quot;, size = 1) + tmap::tm_scale_bar(position = c(&quot;left&quot;, &quot;bottom&quot;)) ) ## stars object downsampled to 877 by 1140 cells. See tm_shape manual (argument raster.downsample) Next create the inset map, which gives the spatial context and helps to locate the area of interest ( nz_map &lt;- tmap::tm_shape(spData::nz) + tmap::tm_polygons() + tmap::tm_shape(spData::nz_height) + tmap::tm_symbols(shape = 2, col = &quot;red&quot;, size = .1) + tmap::tm_shape(nz_region) + tmap::tm_borders(lwd = 3) ) Finally combine the two maps. The viewport() function from the {grid} package is used to give a center location (x and y) and the size (width and height) of the inset map nz_height_map ## stars object downsampled to 877 by 1140 cells. See tm_shape manual (argument raster.downsample) print(nz_map, vp = grid::viewport(.8, .27, width = .5, height = .5)) See also {ggspatial} https://www.mm218.dev/posts/2022-12-12-tools/ Additional details and examples on making maps in R are available in the book “Geocomputation with R” by Lovelace, Nowosad, and Muenchow https://geocompr.robinlovelace.net/adv-map.html Mapping walking (etc) distances. https://walker-data.com/mapboxapi/ ## Making maps with rdeck {-} https://www.mrworthington.com/articles/rstats/mapping-in-r/ Excellent resource on data visualization https://clauswilke.com/dataviz/ "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
