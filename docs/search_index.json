[["thursday-october-6-2022.html", "Thursday October 6, 2022 Assessing the statistical significance of autocorrelation Bivariate spatial autocorrelation Local indicators of spatial autocorrelation Constraining group membership based on spatial autocorrelation", " Thursday October 6, 2022 “Be curious. Read widely. Try new things. I think a lot of what people call intelligence boils down to curiosity.” - Aaron Swartz Lab 3 will be next Thursday. Today Assessing the statistical significance of autocorrelation Bivariate spatial autocorrelation Local indicators of spatial autocorrelation Constraining group membership based on spatial autocorrelation Assessing the statistical significance of autocorrelation Moran’s I and Geary’s C measure the amount of autocorrelation in spatial data. But it is important to understand that attribute values placed arbitrarily across a spatial domain will result in some amount of autocorrelation just by chance. Statistical tests provide a way to guard against being fooled by this chance autocorrelation. So you ask, is the value of Moran’s I significant with respect to the null hypothesis of no autocorrelation? One way to answer this question is to draw an uncertainty band on the regression line in a Moran scatter plot. If a horizontal line can be placed entirely within the band then the slope, which is equivalent to Moran’s I, is not significant against this null hypothesis of no autocorrelation. Consider again the historical demographic data in Mississippi counties. Import the data as a simple feature data frame and assign the geometry a geographic CRS. ( PE.sf &lt;- sf::st_read(dsn = here::here(&quot;data&quot;, &quot;police&quot;), layer = &quot;police&quot;) |&gt; sf::st_set_crs(4326) ) ## Reading layer `police&#39; from data source ## `/Users/jameselsner/Desktop/ClassNotes/ASS-2022/data/police&#39; ## using driver `ESRI Shapefile&#39; ## Simple feature collection with 82 features and 21 fields ## Geometry type: POLYGON ## Dimension: XY ## Bounding box: xmin: -91.64356 ymin: 30.19474 xmax: -88.09043 ymax: 35.00496 ## CRS: NA ## Simple feature collection with 82 features and 21 fields ## Geometry type: POLYGON ## Dimension: XY ## Bounding box: xmin: -91.64356 ymin: 30.19474 xmax: -88.09043 ymax: 35.00496 ## Geodetic CRS: WGS 84 ## First 10 features: ## AREA PERIMETER CNTY_ CNTY_ID NAME STATE_NAME STATE_FIPS CNTY_FIPS ## 1 0.105 1.401 2129 2129 Alcorn Mississippi 28 003 ## 2 0.111 1.485 2130 2130 Tishomingo Mississippi 28 141 ## 3 0.116 1.519 2131 2131 Tippah Mississippi 28 139 ## 4 0.105 1.478 2132 2132 Benton Mississippi 28 009 ## 5 0.127 1.774 2133 2133 De Soto Mississippi 28 033 ## 6 0.181 1.911 2134 2134 Marshall Mississippi 28 093 ## 7 0.119 2.146 2155 2155 Tunica Mississippi 28 143 ## 8 0.103 1.571 2171 2171 Tate Mississippi 28 137 ## 9 0.106 1.394 2176 2176 Prentiss Mississippi 28 117 ## 10 0.109 1.493 2199 2199 Union Mississippi 28 145 ## FIPS FIPSNO POLICE POP TAX TRANSFER INC CRIME UNEMP OWN COLLEGE WHITE ## 1 28003 28003 706 32500 122 12428 8206 43 7 70 23 89 ## 2 28141 28141 247 19100 112 7278 6666 316 8 73 18 96 ## 3 28139 28139 296 18800 93 8606 6865 5 7 71 18 84 ## 4 28009 28009 116 8400 100 3494 6083 24 12 75 16 62 ## 5 28033 28033 1063 56400 116 18555 8731 36 6 77 26 82 ## 6 28093 28093 549 30900 87 10370 5825 316 11 71 22 47 ## 7 28143 28143 291 9500 153 5354 6019 42 15 43 18 27 ## 8 28137 28137 444 20500 137 13783 7837 20 8 67 29 61 ## 9 28117 28117 455 24400 118 14650 6361 41 6 74 20 89 ## 10 28145 28145 364 21400 117 8207 7530 46 5 73 22 86 ## COMMUTE geometry ## 1 8 POLYGON ((-88.35416 34.7626... ## 2 8 POLYGON ((-88.32171 34.4693... ## 3 15 POLYGON ((-88.72614 34.6048... ## 4 41 POLYGON ((-89.23874 34.5935... ## 5 2 POLYGON ((-90.20186 34.7297... ## 6 12 POLYGON ((-89.66407 34.5659... ## 7 3 POLYGON ((-90.19978 34.5617... ## 8 11 POLYGON ((-89.71541 34.5659... ## 9 23 POLYGON ((-88.32171 34.4693... ## 10 20 POLYGON ((-89.24072 34.5017... Variables include police expenditures (POLICE), crime (CRIME), income (INC), unemployment (UNEMP) and other socio-economic characteristics across Mississippi at the county level. Police expenditures are per person 1982 (dollars per person). Personal income is per person in 1982 (dollars per person). Crime is the number of serious crimes per 100,000 person in 1981. Unemployment is percent of people looking for work in 1980. The geometries are polygons that define the county borders. First assign neighbors and attach weights to each county. nbs &lt;- PE.sf |&gt; spdep::poly2nb() wts &lt;- nbs |&gt; spdep::nb2listw() Next compute a spatially-lagged unemployment variable. unemp &lt;- PE.sf$UNEMP Wunemp &lt;- spdep::lag.listw(wts, unemp) Finally make a Moran’s scatter plot. library(ggplot2) data.frame(unemp, Wunemp) |&gt; ggplot(mapping = aes(x = unemp, y = Wunemp)) + geom_point() + geom_smooth(method = lm) + xlab(&quot;Unemployment&quot;) + ylab(&quot;Average neighborhood unemployment&quot;) + theme_minimal() ## `geom_smooth()` using formula &#39;y ~ x&#39; Since a horizontal line can not be placed entirely within the gray band, the slope (Moran’s I) is significant against the null hypothesis of no autocorrelation. More formally the question of whether Moran’s I is statistically significant is answered by comparing the standard deviate (\\(z\\) value) of Moran’s I to the appropriate value from a standard normal distribution. This is done using the spdep::moran.test() function, where the \\(z\\) value is the difference between I and the expected value of I divided by the square root of the variance of I. The function takes a variable name or numeric vector and a spatial weights list object in that order. The argument randomisation = FALSE means the variance of I is computed under the assumption of normally distributed unemployment (UNEMP) rates. ( mt &lt;- spdep::moran.test(PE.sf$UNEMP, listw = wts, randomisation = FALSE) ) ## ## Moran I test under normality ## ## data: PE.sf$UNEMP ## weights: wts ## ## Moran I statistic standard deviate = 3.4102, p-value = 0.0003246 ## alternative hypothesis: greater ## sample estimates: ## Moran I statistic Expectation Variance ## 0.217503452 -0.012345679 0.004542775 Moran’s I is .218 with a variance of .0045. The \\(z\\) value for I is 3.41 giving a \\(p\\)-value of .0003 under the null hypothesis of no autocorrelation. Thus you reject the null hypothesis and conclude there is weak but statistically significant autocorrelation in unemployment rates across Mississippi at the county level. Outputs from the spdep::moran.test() function are in the form of a list. str(mt) ## List of 6 ## $ statistic : Named num 3.41 ## ..- attr(*, &quot;names&quot;)= chr &quot;Moran I statistic standard deviate&quot; ## $ p.value : num 0.000325 ## $ estimate : Named num [1:3] 0.2175 -0.01235 0.00454 ## ..- attr(*, &quot;names&quot;)= chr [1:3] &quot;Moran I statistic&quot; &quot;Expectation&quot; &quot;Variance&quot; ## $ alternative: chr &quot;greater&quot; ## $ method : chr &quot;Moran I test under normality&quot; ## $ data.name : chr &quot;PE.sf$UNEMP \\nweights: wts \\n&quot; ## - attr(*, &quot;class&quot;)= chr &quot;htest&quot; The list element called estimate is a vector of length three containing Moran’s I, the expected value of Moran’s I under the assumption of no autocorrelation, and the variance of Moran’s I. The \\(z\\) value is the difference between I and it’s expected value divided by the square root of the variance. ( mt$estimate[1] - mt$estimate[2] ) / sqrt(mt$estimate[3]) ## Moran I statistic ## 3.410219 The \\(p\\)-value is the area under a standard normal distribution curve to the right (lower.tail = FALSE) of 3.4102 (mt$statistic), the red vertical line in the plot below. pnorm(mt$statistic, lower.tail = FALSE) ## Moran I statistic standard deviate ## 0.000324554 curve(dnorm(x), from = -4, to = 4, lwd = 2) abline(v = mt$statistic, col = &#39;red&#39;) So about .03% of the area lies to the right of the red line. The \\(p\\)-value summarizes the evidence in support of the null hypothesis. The smaller the \\(p\\)-value, the less evidence there is in support of the null hypothesis. The small \\(p\\)-value tells you that the spatial arrangement of the data is unusual with respect to the null hypothesis. The interpretation of the \\(p\\)-value is stated as evidence AGAINST the null hypothesis. This is because interest lies in the null hypothesis being untenable. A \\(p\\)-value less than .01 is said to provide convincing evidence against the null, a \\(p\\)-value between .01 and .05 is said to provide moderate evidence against the null, and a \\(p\\)-value between .05 and .15 is said to provide suggestive, but inconclusive evidence against the null. A \\(p\\)-value greater than .15 is said to provide no evidence against the null. Note you do not interpret no evidence as no autocorrelation. Under the assumption of normal distributed and uncorrelated data, the expected value for Moran’s I is -1/(n-1) where n is the number of regions. A check on the distribution of unemployment rates indicates that normality is somewhat suspect. A good way to check the normality assumption is to use the sm::sm.density() function from the {sm} package. if(!require(sm)) install.packages(&quot;sm&quot;, repos = &quot;http://cran.us.r-project.org&quot;) ## Loading required package: sm ## Package &#39;sm&#39;, version 2.2-5.7: type help(sm) for summary information sm::sm.density(PE.sf$UNEMP, model = &quot;Normal&quot;, xlab = &quot;Unemployment Rates&quot;) The unemployment rates are less “peaked” (lower kurtosis) than a normal distribution. In this case it is better to use the default randomisation = TRUE argument in the spdep::moran.test() function. Further, the assumptions underlying Moran’s test are sensitive to the form of the graph of neighbor relationships and other factors so results should be checked against a test that involves permutations. A random sampling approach to inference is made with the spdep::moran.mc() function. MC stands for Monte Carlo which refers to the city of Monte Carlo in Monaco famous for its gambling casinos. The name of the data vector and the weights list object (listw) are required as is the number of permutations (nsim). Each permutation is a random rearrangement of the unemployment rates across the counties. This removes the spatial autocorrelation but keeps the non-spatial distribution of the unemployment rates. The neighbor topology and weights remain the same. For each permutation (random shuffle of the data values), I is computed and saved. The \\(p\\)-value is obtained as the ratio of the number of permuted I values equal to or exceeding the observed I over the number of permutation plus one. In the case where there are 5 permuted I values greater or equal to the observed value based on 99 simulations, the \\(p\\)-value is 5/(99 + 1) = .05. For example, if you want inference on I using 9999 permutations type set.seed(40453) ( mP &lt;- spdep::moran.mc(PE.sf$UNEMP, listw = wts, nsim = 9999) ) ## ## Monte-Carlo simulation of Moran I ## ## data: PE.sf$UNEMP ## weights: wts ## number of simulations + 1: 10000 ## ## statistic = 0.2175, observed rank = 9991, p-value = 9e-04 ## alternative hypothesis: greater Nine of the permutations yield a Moran’s I greater than .218, hence the \\(p\\)-value as evidence in support of the null hypothesis (the true value for Moran’s I is zero) is .0009. Note: you initiate the random number generator with a seed value (any will do) so that the set of random permutations of the values across the domain will be the same each time you run this code chunk. This is important for reproducibility. The default random number generator seed value is determined from the current time (internal clock) and so no random permutations will be identical. To control the seed use the set.seed() function. The values of I computed for each permutation are saved in the vector mP$res. head(mP$res) ## [1] -0.03052409 0.05019765 0.01346706 0.03189984 -0.07625158 -0.07398726 tail(mP$res) ## [1] 0.01973190 -0.01000012 -0.04472215 -0.12488347 -0.01269481 0.21750345 The last value in the vector is I computed using the data in the correct counties. The \\(p\\)-value as evidence in support of the null hypothesis that I is zero is given as sum(mP$res &gt; mP$res[10000])/9999 ## [1] 0.00090009 A density graph displays the distribution of permuted I’s. df &lt;- data.frame(mp = mP$res[-10000]) ggplot(data = df, mapping = aes(mp)) + geom_density() + geom_rug() + geom_vline(xintercept = mP$res[10000], color = &quot;red&quot;, size = 2) + theme_minimal() The density curve is centered just to the left of zero consistent with the theoretical expectation (mean). What do you do with the knowledge that the unemployment rates have significant autocorrelation? By itself, not much, but it can provide notice that something might be going on in certain regions (hot spot analysis). The knowledge is more useful after other factors are considered. In the language of statistics, knowledge of significant autocorrelation in the model residuals can help you build a better model. Bivariate spatial autocorrelation The idea of spatial autocorrelation can be extended to two variables. It is motivated by the fact that aspatial bi-variate association measures, like Pearson’s correlation, do not recognize the spatial arrangement of the regions. Consider the correlation between police expenditure (POLICE) and the amount of crime (CRIME) in the police expenditure data set. police &lt;- PE.sf$POLICE crime &lt;- PE.sf$CRIME cor.test(police, crime, method = &quot;pearson&quot;) ## ## Pearson&#39;s product-moment correlation ## ## data: police and crime ## t = 6.2916, df = 80, p-value = 1.569e-08 ## alternative hypothesis: true correlation is not equal to 0 ## 95 percent confidence interval: ## 0.4094516 0.7043990 ## sample estimates: ## cor ## 0.5753377 You note a significant (direct) correlation (\\(p\\)-value &lt;&lt; .01) exists between these two variables. But you also note some significant spatial autocorrelation in each of the variables separately. spdep::moran.test(police, listw = wts) ## ## Moran I test under randomisation ## ## data: police ## weights: wts ## ## Moran I statistic standard deviate = 1.7899, p-value = 0.03674 ## alternative hypothesis: greater ## sample estimates: ## Moran I statistic Expectation Variance ## 0.087185424 -0.012345679 0.003092257 spdep::moran.test(crime, listw = wts) ## ## Moran I test under randomisation ## ## data: crime ## weights: wts ## ## Moran I statistic standard deviate = 2.2072, p-value = 0.01365 ## alternative hypothesis: greater ## sample estimates: ## Moran I statistic Expectation Variance ## 0.103588680 -0.012345679 0.002758842 The Lee statistic integrates the Pearson correlation as an aspatial bi-variate association metric with Moran’s I as a uni-variate spatial autocorrelation metric. The formula is \\[ L(x,y) = \\frac{n}{\\sum_{i=1}^{n}(\\sum_{j=1}^{n}w_{ij})^2} \\frac{\\sum_{i=1}^{n}(\\sum_{j=1}^{n}w_{ij}(x_i-\\bar{x})) ((\\sum_{j=1}^{n}w_{ij}(y_j-\\bar{y}))}{\\sqrt{\\sum_{i=1}^{n}(x_i - \\bar{x})^2} \\sqrt{\\sum_{i=1}^{n}(y_i - \\bar{y})^2}} \\] The formula is implemented in the spdep::lee() function where the first two arguments are the variables of interest and you need to include the weights matrix and the number of regions. The output from this function is a list of two with the first being the value of Lee’s statistic (L). spdep::lee(crime, police, listw = wts, n = length(nbs))$L ## [1] 0.1306991 Values of L range between -1 and +1 with the value here of .13 indicating relatively weak bi-variate spatial autocorrelation between crime and police expenditures. You interpret this to mean that crime in a county has some influence on police expenditure in that county AND some influence on police expenditure in the neighboring counties, but not much. The crime and police variables can not be adequately described with a normal distribution. par(mfrow = c(2, 1)) sm::sm.density(crime, model = &quot;normal&quot;) sm::sm.density(police, model = &quot;normal&quot;) Thus you perform a non-parametric test on the bi-variate spatial autocorrelation with the spdep::lee.mc() function. The crime and police expenditure values are randomly permuted and values of Lee’s statistic (L) are computed for each permutation. spdep::lee.mc(crime, police, listw = wts, nsim = 999) ## ## Monte-Carlo simulation of Lee&#39;s L ## ## data: crime , police ## weights: wts ## number of simulations + 1: 1000 ## ## statistic = 0.1307, observed rank = 760, p-value = 0.24 ## alternative hypothesis: greater Based on a \\(p\\)-value that exceeds .05 you conclude that there is no significant bi-variate spatial autocorrelation between crime and police expenditure in these data. Local indicators of spatial autocorrelation The Moran’s I statistic was first used in the 1950s. Localization of the statistic was presented by Luc Anselin in 1995 (Anselin, L. 1995. Local indicators of spatial association, Geographical Analysis, 27, 93–115). Earlier you saw the raster::MoranLocal() function from the {raster} package returns a raster of local Moran’s I values. Local I is a deconstruction of global I where geographic proximity is used in two ways. (1) to define and weight neighbors and (2) to determine the spatial scale over which I is computed. Using queen’s contiguity you determine the neighborhood topology and the weights for the police expenditure data from Mississippi. Here you print them in the full matrix form with the spdep::list2mat() function. round(spdep::listw2mat(wts)[1:5, 1:10], 2) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] ## 1 0.00 0.33 0.33 0.00 0 0.00 0.00 0.00 0.33 0.00 ## 2 0.33 0.00 0.00 0.00 0 0.00 0.00 0.00 0.33 0.00 ## 3 0.25 0.00 0.00 0.25 0 0.00 0.00 0.00 0.25 0.25 ## 4 0.00 0.00 0.33 0.00 0 0.33 0.00 0.00 0.00 0.33 ## 5 0.00 0.00 0.00 0.00 0 0.33 0.33 0.33 0.00 0.00 The matrix shows that the first county has three neighbors 2, 3, and 9 and each get a weight of 1/3. The third county has four neighbors 1, 4, 9 and 10 and each gets a weight of 1/4. Compute local Moran’s I on the percentage of white people using the spdep::localmoran() function. Two arguments are needed (1) the attribute variable for which you want to compute local correlation and (2) the weights matrix as a list object. Ii_stats &lt;- spdep::localmoran(PE.sf$WHITE, listw = wts) str(Ii_stats) ## &#39;localmoran&#39; num [1:82, 1:5] 2.28138 2.97475 1.31244 0.00231 -1.03216 ... ## - attr(*, &quot;dimnames&quot;)=List of 2 ## ..$ : chr [1:82] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## ..$ : chr [1:5] &quot;Ii&quot; &quot;E.Ii&quot; &quot;Var.Ii&quot; &quot;Z.Ii&quot; ... ## - attr(*, &quot;call&quot;)= language spdep::localmoran(x = PE.sf$WHITE, listw = wts) ## - attr(*, &quot;quadr&quot;)=&#39;data.frame&#39;: 82 obs. of 3 variables: ## ..$ mean : Factor w/ 4 levels &quot;Low-Low&quot;,&quot;High-Low&quot;,..: 4 4 4 4 2 3 1 1 4 4 ... ## ..$ median: Factor w/ 4 levels &quot;Low-Low&quot;,&quot;High-Low&quot;,..: 4 4 4 3 2 3 1 1 4 4 ... ## ..$ pysal : Factor w/ 4 levels &quot;Low-Low&quot;,&quot;High-Low&quot;,..: 4 4 4 4 2 3 1 1 4 4 ... The local I values are stored in the first column of a matrix where the rows are the counties. The other columns are the expected values for I, the variances of I, the \\(z\\) values and the \\(p\\)-values. For example, the local I statistics from the first six counties are given by typing head(Ii_stats) ## Ii E.Ii Var.Ii Z.Ii Pr(z != E(Ii)) ## 1 2.281375143 -2.748824e-02 7.124247e-01 2.735450 0.006229509 ## 2 2.974750377 -4.354053e-02 1.109833e+00 2.865051 0.004169423 ## 3 1.312440365 -1.827251e-02 3.539514e-01 2.236725 0.025304339 ## 4 0.002313108 -2.007906e-07 5.351069e-06 1.000031 0.317295645 ## 5 -1.032155817 -1.511126e-02 3.966295e-01 -1.614907 0.106330864 ## 6 -0.493034653 -8.356103e-03 1.291002e-01 -1.348933 0.177358557 Because the local I values must average to the global value (when using row standardized weights), they can take on values outside the range between -1 and 1. A summary() method on the first column of the Li object gives statistics from the non-spatial distribution of I’s. summary(Ii_stats[, 1]) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## -1.03216 0.01733 0.26984 0.56348 1.05945 2.97475 To make a map of the values, you start by attaching the matrix columns of interest to the simple feature data frame. Here you attach Ii (local Moran’s), Vi (variance), and Pi (\\(p\\)-value). PE.sf$Ii &lt;- Ii_stats[, 1] PE.sf$Vi &lt;- Ii_stats[, 3] PE.sf$Pi &lt;- Ii_stats[, 5] Then you use {ggplot2} together with the geom_sf() function to make a thematic map. ( g1 &lt;- ggplot(data = PE.sf) + geom_sf(mapping = aes(fill = Ii)) + scale_fill_gradient2(low = &quot;green&quot;, high = &quot;blue&quot;) ) You also map the variances. ggplot(data = PE.sf) + geom_sf(mapping = aes(fill = Vi)) + scale_fill_gradient() Variances are larger for counties near the boundaries because the sample sizes are smaller. Compare the map of local autocorrelation with a map of percent white. ( g2 &lt;- ggplot(data = PE.sf) + geom_sf(mapping = aes(fill = WHITE)) + scale_fill_gradient(low = &quot;black&quot;, high = &quot;white&quot;) ) Plot them together. library(patchwork) g1 + g2 Areas where percent white is high over the northeast are also areas with the largest spatial correlation. Other areas of high spatial correlation include the Mississippi Valley and in the south. Note the county with the most negative spatial correlation is the county in the northwest with a fairly high percentage of whites neighbored by counties with much lower percentages of whites. Local values of Lee’s bi-variate spatial autocorrelation are available from the spdep::lee() function. Here you compute the local Lee statistic for each county, attach the values to the simple feature data frame, then make a thematic map with functions from the {tmap} package. lee_stat &lt;- spdep::lee(crime, police, listw = wts, n = length(nbs)) PE.sf$localL &lt;- lee_stat$localL tmap::tm_shape(PE.sf) + tmap::tm_fill(&quot;localL&quot;, title = &quot;&quot;) + tmap::tm_borders(col = &quot;gray70&quot;) + tmap::tm_layout(title = &quot;Local bi-variate spatial autocorrelation&quot;, legend.outside = TRUE) ## Variable(s) &quot;localL&quot; contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette. Areas in dark green indicate where the correlation between crime and policing is most influenced by neighboring crime and policing. Population and tornado reports Is the frequency of tornado reports correlated with the number of people in a region? Might this correlation extend to the number of people in neighboring regions? To answer these questions you quantify the non-spatial correlation and the bi-variate spatial autocorrelation between tornado occurrences and population. To keep this manageable you focus on one state (Iowa). Start by getting the U.S. Census data with functions from the {tidycensus} package. Downloading U.S. census data using functions from the {tidycensus} package requires you register with the Census Bureau. You can get an API key from http://api.census.gov/data/key_signup.html. Then use the tidycensus::census_api_key() function and put your key in quotes. tidycensus::census_api_key(&quot;YOUR API KEY GOES HERE&quot;) The get_decennial() function grants access to the 1990, 2000, and 2010 decennial US Census data and the get_acs() function grants access to the 5-year American Community Survey data. For example, here is how you get county-level population for Iowa. Counties.sf &lt;- tidycensus::get_acs(geography = &quot;county&quot;, variables = &quot;B02001_001E&quot;, state = &quot;IA&quot;, geometry = TRUE) ## Getting data from the 2016-2020 5-year ACS ## Downloading feature geometry from the Census website. To cache shapefiles for use in future sessions, set `options(tigris_use_cache = TRUE)`. ## | | | 0% | | | 1% | |= | 1% | |= | 2% | |== | 2% | |== | 3% | |=== | 4% | |=== | 5% | |==== | 5% | |==== | 6% | |===== | 7% | |===== | 8% | |====== | 8% | |======= | 10% | |======== | 11% | |========= | 12% | |========= | 13% | |============ | 17% | |============ | 18% | |============= | 18% | |============= | 19% | |============== | 19% | |============== | 20% | |============== | 21% | |=============== | 21% | |=============== | 22% | |================ | 23% | |================= | 24% | |================= | 25% | |================== | 25% | |================== | 26% | |=================== | 26% | |====================== | 31% | |======================= | 32% | |======================= | 33% | |======================== | 34% | |======================== | 35% | |========================= | 36% | |========================== | 37% | |========================== | 38% | |=========================== | 39% | |============================ | 40% | |============================= | 41% | |============================= | 42% | |================================ | 45% | |================================ | 46% | |================================= | 46% | |================================= | 47% | |================================= | 48% | |================================== | 48% | |================================== | 49% | |=================================== | 49% | |=================================== | 50% | |=================================== | 51% | |==================================== | 52% | |===================================== | 53% | |====================================== | 54% | |====================================== | 55% | |======================================= | 55% | |======================================= | 56% | |======================================== | 57% | |======================================== | 58% | |========================================= | 58% | |========================================= | 59% | |========================================== | 60% | |=========================================== | 61% | |============================================ | 63% | |============================================= | 64% | |============================================= | 65% | |============================================== | 65% | |============================================== | 66% | |================================================= | 70% | |================================================== | 71% | |=================================================== | 72% | |=================================================== | 73% | |==================================================== | 74% | |==================================================== | 75% | |===================================================== | 75% | |===================================================== | 76% | |====================================================== | 76% | |====================================================== | 77% | |======================================================= | 78% | |======================================================= | 79% | |======================================================== | 80% | |========================================================= | 81% | |========================================================= | 82% | |========================================================== | 83% | |=========================================================== | 84% | |============================================================ | 86% | |============================================================= | 87% | |============================================================== | 88% | |================================================================ | 91% | |================================================================= | 92% | |==================================================================== | 97% | |======================================================================| 100% The code returns a simple feature data frame with county borders as multi-polygons. The variable B02001_001E is the 2016-2020 population estimate in each county within the state. Next get the tornado data and count the number of tracks by county. A single track can intersect more than one county. Torn.sf &lt;- sf::st_read(dsn = here::here(&quot;data&quot;, &quot;1950-2020-torn-aspath&quot;), layer = &quot;1950-2020-torn-aspath&quot;) |&gt; sf::st_transform(crs = sf::st_crs(Counties.sf)) |&gt; dplyr::filter(yr &gt;= 2016) ## Reading layer `1950-2020-torn-aspath&#39; from data source ## `/Users/jameselsner/Desktop/ClassNotes/ASS-2022/data/1950-2020-torn-aspath&#39; ## using driver `ESRI Shapefile&#39; ## Simple feature collection with 66244 features and 22 fields ## Geometry type: LINESTRING ## Dimension: XY ## Bounding box: xmin: -163.53 ymin: 17.7212 xmax: -64.7151 ymax: 61.02 ## Geodetic CRS: WGS 84 ( TorCounts.df &lt;- Torn.sf |&gt; sf::st_intersection(Counties.sf) |&gt; sf::st_drop_geometry() |&gt; dplyr::group_by(GEOID) |&gt; dplyr::summarize(nT = dplyr::n()) ) ## Warning: attribute variables are assumed to be spatially constant throughout all ## geometries ## # A tibble: 82 × 2 ## GEOID nT ## &lt;chr&gt; &lt;int&gt; ## 1 19001 7 ## 2 19003 3 ## 3 19007 5 ## 4 19011 7 ## 5 19013 4 ## 6 19015 5 ## 7 19017 1 ## 8 19019 4 ## 9 19021 1 ## 10 19023 1 ## # … with 72 more rows ## # ℹ Use `print(n = ...)` to see more rows Next join the counts to the simple feature data frame by the common column name GEOID. Counties.sf &lt;- Counties.sf |&gt; dplyr::left_join(TorCounts.df, by = &quot;GEOID&quot;) |&gt; dplyr::mutate(nT = tidyr::replace_na(nT, 0)) |&gt; dplyr::mutate(Area = sf::st_area(Counties.sf), rate = nT/Area/(2020 - 2016 + 1) * 10^10, lpop = log10(estimate)) Note that some counties had no tornadoes and the dplyr::left_join() returns a value of NA for those. You use dplyr::mutate() with tidyr::replace_na() to turn those counts to a value of 0. Make a two-panel map displaying the log of the population and the tornado rates. map1 &lt;- tmap::tm_shape(Counties.sf) + tmap::tm_borders(col = &quot;gray70&quot;) + tmap::tm_fill(col = &quot;lpop&quot;, title = &quot;Log Population&quot;, palette = &quot;Blues&quot;) + tmap::tm_layout(legend.outside = &quot;TRUE&quot;) map2 &lt;- tmap::tm_shape(Counties.sf) + tmap::tm_borders(col = &quot;gray70&quot;) + tmap::tm_fill(col = &quot;rate&quot;, title = &quot;Annual Rate\\n[/10,000 sq. km]&quot;, palette = &quot;Greens&quot;) + tmap::tm_layout(legend.outside = &quot;TRUE&quot;) tmap::tmap_arrange(map1, map2) There appears some relationship. The non-spatial correlation between the two variables is obtained with the cor.test() function. lpop &lt;- Counties.sf$lpop rate &lt;- as.numeric(Counties.sf$rate) cor.test(lpop, rate) ## ## Pearson&#39;s product-moment correlation ## ## data: lpop and rate ## t = 4.0482, df = 97, p-value = 0.0001038 ## alternative hypothesis: true correlation is not equal to 0 ## 95 percent confidence interval: ## 0.1975898 0.5372624 ## sample estimates: ## cor ## 0.3801724 The bi-variate spatial autocorrelation is assessed using the Lee statistic. A formal non-parametric test under the null hypothesis of no bi-variate spatial autocorrelation is done using a Monte Carlo simulation. nbs &lt;- spdep::poly2nb(Counties.sf) wts &lt;- spdep::nb2listw(nbs) lee_stat &lt;- spdep::lee(lpop, rate, listw = wts, n = length(nbs)) lee_stat$L ## [1] 0.2357866 spdep::lee.mc(lpop, rate, listw = wts, nsim = 9999) ## ## Monte-Carlo simulation of Lee&#39;s L ## ## data: lpop , rate ## weights: wts ## number of simulations + 1: 10000 ## ## statistic = 0.23579, observed rank = 10000, p-value = 1e-04 ## alternative hypothesis: greater Finally you map out the local variation in the bi-variate spatial autocorrelation. Counties.sf$localL &lt;- lee_stat$localL tmap::tm_shape(Counties.sf) + tmap::tm_fill(&quot;localL&quot;, title = &quot;Local Bivariate\\nSpatial Autocorrelation&quot;) + tmap::tm_borders(col = &quot;gray70&quot;) + tmap::tm_layout(legend.outside = TRUE) ## Variable(s) &quot;localL&quot; contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette. What might cause this? Cedar County (dark green) lies between the cities of Cedar Rapids (to the northwest), Iowa City (to the west) and the Quad Cities (to the east). Commuters from neighboring counties into cities like Cedar Rapids provide an ad hoc spotter network for all kinds of phenomenon including severe weather and tornadoes. Repeat this analysis for the state of Kansas and compare/contrast the results and interpretation. Also, compare local Lee with local Moran. Ii_stats &lt;- spdep::localmoran(rate, listw = wts) Counties.sf$localI = Ii_stats[, 1] tmap::tm_shape(Counties.sf) + tmap::tm_borders(col = &quot;gray70&quot;) + tmap::tm_fill(col = &quot;localI&quot;, title = &quot;Local Autocorrelation&quot;, palette = &quot;Purples&quot;) + tmap::tm_layout(legend.outside = &quot;TRUE&quot;) The clustering of tornado occurrences coincides with the largest population corridor in the state. Constraining group membership based on spatial autocorrelation As a spatial data analyst you likely will face the situation in which there are many variables and you need to group them in a way that minimizes inter-group variation but maximizes between-group variation. If you know the number of groups before hand then a common grouping (or clustering) method is called K-means. If your data is spatial you may want the additional constraint that the resulting groups be geographically linked. There are many situations that require separating geographies into discrete but contiguous regions (“regionalization”) such as designing communities, planning areas, amenity zones, logistical units, or for setting up experiments with real world geographic constraints. Optimal grouping using only traditional cluster metrics is generally sub-optimal in practice for regionalization because the metrics do not consider geographic contiguity. Unconstrained grouping on data with spatial characteristics may result in contiguous regions because of autocorrelation, but if you want to ensure that all groups are spatially-contiguous you need a method specifically designed for the task. The ‘skater’ algorithm available in the {spdep} package is well-implemented and well-documented. The ‘skater’ algorithm (spatial ’k’luster analysis by tree edge removal) builds a connectivity graph to represent spatial relationships between neighboring areas, where each area is represented by a node and edges represent connections between areas. Edge costs are calculated by evaluating the dissimilarity in attribute space between neighboring areas. The connectivity graph is reduced by pruning edges with higher dissimilarity. Consider again the crime data at the tract level in the city of Columbus, Ohio. The tract polygons are projected with arbitrary spatial coordinates. ( CC.sf &lt;- sf::st_read(dsn = here::here(&quot;data&quot;, &quot;columbus&quot;), layer = &quot;columbus&quot;) ) ## Reading layer `columbus&#39; from data source ## `/Users/jameselsner/Desktop/ClassNotes/ASS-2022/data/columbus&#39; ## using driver `ESRI Shapefile&#39; ## Simple feature collection with 49 features and 20 fields ## Geometry type: POLYGON ## Dimension: XY ## Bounding box: xmin: 5.874907 ymin: 10.78863 xmax: 11.28742 ymax: 14.74245 ## CRS: NA ## Simple feature collection with 49 features and 20 fields ## Geometry type: POLYGON ## Dimension: XY ## Bounding box: xmin: 5.874907 ymin: 10.78863 xmax: 11.28742 ymax: 14.74245 ## CRS: NA ## First 10 features: ## AREA PERIMETER COLUMBUS_ COLUMBUS_I POLYID NEIG HOVAL INC CRIME ## 1 0.309441 2.440629 2 5 1 5 80.467 19.531 15.725980 ## 2 0.259329 2.236939 3 1 2 1 44.567 21.232 18.801754 ## 3 0.192468 2.187547 4 6 3 6 26.350 15.956 30.626781 ## 4 0.083841 1.427635 5 2 4 2 33.200 4.477 32.387760 ## 5 0.488888 2.997133 6 7 5 7 23.225 11.252 50.731510 ## 6 0.283079 2.335634 7 8 6 8 28.750 16.029 26.066658 ## 7 0.257084 2.554577 8 4 7 4 75.000 8.438 0.178269 ## 8 0.204954 2.139524 9 3 8 3 37.125 11.337 38.425858 ## 9 0.500755 3.169707 10 18 9 18 52.600 17.586 30.515917 ## 10 0.246689 2.087235 11 10 10 10 96.400 13.598 34.000835 ## OPEN PLUMB DISCBD X Y NSA NSB EW CP THOUS NEIGNO ## 1 2.850747 0.217155 5.03 38.80 44.07 1 1 1 0 1000 1005 ## 2 5.296720 0.320581 4.27 35.62 42.38 1 1 0 0 1000 1001 ## 3 4.534649 0.374404 3.89 39.82 41.18 1 1 1 0 1000 1006 ## 4 0.394427 1.186944 3.70 36.50 40.52 1 1 0 0 1000 1002 ## 5 0.405664 0.624596 2.83 40.01 38.00 1 1 1 0 1000 1007 ## 6 0.563075 0.254130 3.78 43.75 39.28 1 1 1 0 1000 1008 ## 7 0.000000 2.402402 2.74 33.36 38.41 1 1 0 0 1000 1004 ## 8 3.483478 2.739726 2.89 36.71 38.71 1 1 0 0 1000 1003 ## 9 0.527488 0.890736 3.17 43.44 35.92 1 1 1 0 1000 1018 ## 10 1.548348 0.557724 4.33 47.61 36.42 1 1 1 0 1000 1010 ## geometry ## 1 POLYGON ((8.624129 14.23698... ## 2 POLYGON ((8.25279 14.23694,... ## 3 POLYGON ((8.653305 14.00809... ## 4 POLYGON ((8.459499 13.82035... ## 5 POLYGON ((8.685274 13.63952... ## 6 POLYGON ((9.401384 13.5504,... ## 7 POLYGON ((8.037741 13.60752... ## 8 POLYGON ((8.247527 13.58651... ## 9 POLYGON ((9.333297 13.27242... ## 10 POLYGON ((10.08251 13.03377... First, create choropleth maps of housing value, income, and crime. tmap::tm_shape(CC.sf) + tmap::tm_fill(col = c(&quot;HOVAL&quot;, &quot;INC&quot;, &quot;CRIME&quot;)) ## Warning: Currect projection of shape CC.sf unknown. Long-lat (WGS84) is assumed. The maps show distinct regional patterns. Housing values and income are clustered toward the southeast and crime is clustered in the center. But although housing values are also high in the north you don’t necessarily want to group that tract with those in the southeast because they are geographically distinct. To group these patterns under the constraint of spatial contiguity you first scale the attribute values and center them using the scale() function. Scaling and centering variables should be done before any type of clustering procedure. ( CCs.df &lt;- CC.sf |&gt; dplyr::mutate(HOVALs = scale(HOVAL), INCs = scale(INC), CRIMEs = scale(CRIME)) |&gt; dplyr::select(HOVALs, INCs, CRIMEs) |&gt; sf::st_drop_geometry() ) ## HOVALs INCs CRIMEs ## 1 2.27610855 0.90403637 -1.15961852 ## 2 0.33200225 1.20228067 -0.97579369 ## 3 -0.65450986 0.27721488 -0.26906635 ## 4 -0.28355918 -1.73545197 -0.16382075 ## 5 -0.82373916 -0.54755948 0.93250061 ## 6 -0.52454175 0.29001413 -0.54160387 ## 7 1.98005188 -1.04095129 -2.08883352 ## 8 -0.07100723 -0.53265603 0.19704853 ## 9 0.76701615 0.56301041 -0.27569218 ## 10 3.13893423 -0.13622431 -0.06741470 ## 11 -1.01462975 -1.21120127 1.62242856 ## 12 -1.00379913 -0.75866244 1.28954855 ## 13 0.17674452 -0.84615445 0.69251980 ## 14 0.24172862 -0.77356589 1.31109176 ## 15 -1.10669054 -0.78934601 0.80424271 ## 16 -1.06336790 -1.18349839 1.17796908 ## 17 0.17945213 -0.80249612 0.10398880 ## 18 1.16775124 -0.20863754 0.52794726 ## 19 -0.42435801 -0.48338699 1.15903863 ## 20 2.31943098 2.92722331 -2.08611253 ## 21 -0.99973763 -0.65223429 0.29555480 ## 22 -0.43248096 -0.46743153 -0.08509252 ## 23 0.50345189 1.18878008 -0.90128119 ## 24 0.79950834 -0.02436078 0.18939933 ## 25 -1.11210588 -1.03691859 1.56408123 ## 26 -0.98213783 -1.10284443 0.34908475 ## 27 -0.23482130 -0.62295340 1.05579183 ## 28 -0.84404667 -1.14299607 1.30234528 ## 29 -0.32146659 -0.99834496 1.53128622 ## 30 -0.86300035 -0.08222123 2.01787200 ## 31 -0.35937401 0.44974438 -1.04300226 ## 32 0.10092968 0.80076407 -0.95524408 ## 33 -0.80343164 -0.78145595 0.40875576 ## 34 -0.54078771 0.10047751 -0.66667072 ## 35 -0.61931016 -0.27368671 0.24182446 ## 36 -0.11568382 0.76517130 -1.24451072 ## 37 0.26338981 0.46324498 0.43725866 ## 38 -0.85216962 -0.57298301 1.11056729 ## 39 0.06302227 0.71923344 -0.95791733 ## 40 1.27335038 2.71033430 -1.12882028 ## 41 0.19840570 1.37323217 -0.96961443 ## 42 0.31933030 2.01600877 -1.11384361 ## 43 -0.68970950 -0.17444727 0.09172721 ## 44 -0.26731322 0.45342623 -0.54784308 ## 45 -0.57961574 -0.04206959 -0.36458895 ## 46 2.03962048 0.69240723 -1.11153410 ## 47 0.22006716 0.80216710 -0.43664372 ## 48 -0.63014089 -0.44919672 -0.50702314 ## 49 -0.14276051 0.77516538 -0.75228685 Next create adjacency neighbors using queen contiguity. nbs &lt;- spdep::poly2nb(CC.sf, queen = TRUE) plot(CC.sf$geometry) plot(nbs, sf::st_centroid(sf::st_geometry(CC.sf)), add = TRUE) Next combine the contiguity graph with your scaled attribute data to calculate edge costs based on distances between each node. The function spdep::nbcosts() provides distance methods for Euclidean, Manhattan, Canberra, binary, Minkowski, and Mahalanobis, and defaults to Euclidean if not specified like here. Save the object of class nbdist with name edge_costs. edge_costs &lt;- spdep::nbcosts(nbs, data = CCs.df) Next transform the edge costs into spatial weights using the spdep::nb2listw() function before constructing the minimum spanning tree with the weights list. wts &lt;- spdep::nb2listw(nbs, glist = edge_costs, style = &quot;B&quot;) mst &lt;- spdep::mstree(wts) head(mst) ## [,1] [,2] [,3] ## [1,] 12 16 0.4432652 ## [2,] 16 25 0.4158649 ## [3,] 25 28 0.3893763 ## [4,] 16 11 0.4479811 ## [5,] 16 15 0.5448893 ## [6,] 15 5 0.3936652 Edges with higher dissimilarity are removed leaving a set of nodes and edges that take the minimum sum of dissimilarities across all edges of the tree (a minimum spanning tree). The edge connecting node (tract) 12 with node (tract) 16 has a dissimilarity of .44 units. The edge connecting tract 16 with tract 25 has a dissimilarity of .42 units. Finally, the spdep::skater() function partitions the graph by identifying which edges to remove based on dissimilarity while maximizing the between-group variation. The ncuts = argument specifies the number of partitions to make, resulting in ncuts + 1 groups. clus5 &lt;- spdep::skater(edges = mst[, 1:2], data = CCs.df, ncuts = 4) Where are these groups located? CC.sf &lt;- CC.sf |&gt; dplyr::mutate(Group = clus5$groups) ggplot() + geom_sf(data = CC.sf, mapping = aes(fill = factor(Group))) The map shows five distinct regions based on the three variables of income, housing value, and crime. Importantly the regions are contiguous. Region 1 encompasses most tracts in the urban core where housing values and income are low and crime rates are highest. Regions 2 and 3 in the east and west are where housing values and income are moderately high and crime rates are lower. Region 4 is where income and housing values are highest and crime is the lowest. As a comparison, here is the result of grouping the same three variables using hierarchical clustering using the method of minimum variance (Ward) and without regard to spatial contiguity. dd &lt;- dist(CCs.df) hc &lt;- hclust(dd, method = &quot;ward.D&quot;) hcGroup &lt;- cutree(hc, k = 5) CC.sf &lt;- CC.sf |&gt; dplyr::mutate(hcGroup = hcGroup) ggplot() + geom_sf(data = CC.sf, mapping = aes(fill = factor(hcGroup))) Here the map shows five regions but the regions are not contiguous. More information: https://www.tandfonline.com/doi/abs/10.1080/13658810600665111 Also the {motif} package has functions that implement and extend ideas of the pattern-based spatial analysis. They can be used to describe spatial patterns of categorical raster data for any defined regular and irregular areas. Patterns are represented quantitatively using built-in signatures based on co-occurrence matrices but the functions are flexible to allow for user-defined functions. Functions enable spatial analysis such as search, change detection, and clustering to be performed on spatial patterns. https://jakubnowosad.com/motif/ "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
